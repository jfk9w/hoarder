// Code generated by ogen, DO NOT EDIT.

package firefly

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *Account) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Account) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.AccountRole.Set {
			e.FieldStart("account_role")
			s.AccountRole.Encode(e)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.CurrencySymbol.Set {
			e.FieldStart("currency_symbol")
			s.CurrencySymbol.Encode(e)
		}
	}
	{
		if s.CurrencyDecimalPlaces.Set {
			e.FieldStart("currency_decimal_places")
			s.CurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		if s.CurrentBalance.Set {
			e.FieldStart("current_balance")
			s.CurrentBalance.Encode(e)
		}
	}
	{
		if s.CurrentBalanceDate.Set {
			e.FieldStart("current_balance_date")
			s.CurrentBalanceDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Iban.Set {
			e.FieldStart("iban")
			s.Iban.Encode(e)
		}
	}
	{
		if s.Bic.Set {
			e.FieldStart("bic")
			s.Bic.Encode(e)
		}
	}
	{
		if s.AccountNumber.Set {
			e.FieldStart("account_number")
			s.AccountNumber.Encode(e)
		}
	}
	{
		if s.OpeningBalance.Set {
			e.FieldStart("opening_balance")
			s.OpeningBalance.Encode(e)
		}
	}
	{
		if s.CurrentDebt.Set {
			e.FieldStart("current_debt")
			s.CurrentDebt.Encode(e)
		}
	}
	{
		if s.OpeningBalanceDate.Set {
			e.FieldStart("opening_balance_date")
			s.OpeningBalanceDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.VirtualBalance.Set {
			e.FieldStart("virtual_balance")
			s.VirtualBalance.Encode(e)
		}
	}
	{
		if s.IncludeNetWorth.Set {
			e.FieldStart("include_net_worth")
			s.IncludeNetWorth.Encode(e)
		}
	}
	{
		if s.CreditCardType.Set {
			e.FieldStart("credit_card_type")
			s.CreditCardType.Encode(e)
		}
	}
	{
		if s.MonthlyPaymentDate.Set {
			e.FieldStart("monthly_payment_date")
			s.MonthlyPaymentDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LiabilityType.Set {
			e.FieldStart("liability_type")
			s.LiabilityType.Encode(e)
		}
	}
	{
		if s.LiabilityDirection.Set {
			e.FieldStart("liability_direction")
			s.LiabilityDirection.Encode(e)
		}
	}
	{
		if s.Interest.Set {
			e.FieldStart("interest")
			s.Interest.Encode(e)
		}
	}
	{
		if s.InterestPeriod.Set {
			e.FieldStart("interest_period")
			s.InterestPeriod.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.Latitude.Set {
			e.FieldStart("latitude")
			s.Latitude.Encode(e)
		}
	}
	{
		if s.Longitude.Set {
			e.FieldStart("longitude")
			s.Longitude.Encode(e)
		}
	}
	{
		if s.ZoomLevel.Set {
			e.FieldStart("zoom_level")
			s.ZoomLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfAccount = [31]string{
	0:  "created_at",
	1:  "updated_at",
	2:  "active",
	3:  "order",
	4:  "name",
	5:  "type",
	6:  "account_role",
	7:  "currency_id",
	8:  "currency_code",
	9:  "currency_symbol",
	10: "currency_decimal_places",
	11: "current_balance",
	12: "current_balance_date",
	13: "iban",
	14: "bic",
	15: "account_number",
	16: "opening_balance",
	17: "current_debt",
	18: "opening_balance_date",
	19: "virtual_balance",
	20: "include_net_worth",
	21: "credit_card_type",
	22: "monthly_payment_date",
	23: "liability_type",
	24: "liability_direction",
	25: "interest",
	26: "interest_period",
	27: "notes",
	28: "latitude",
	29: "longitude",
	30: "zoom_level",
}

// Decode decodes Account from json.
func (s *Account) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Account to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "account_role":
			if err := func() error {
				s.AccountRole.Reset()
				if err := s.AccountRole.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_role\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "currency_symbol":
			if err := func() error {
				s.CurrencySymbol.Reset()
				if err := s.CurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_symbol\"")
			}
		case "currency_decimal_places":
			if err := func() error {
				s.CurrencyDecimalPlaces.Reset()
				if err := s.CurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_decimal_places\"")
			}
		case "current_balance":
			if err := func() error {
				s.CurrentBalance.Reset()
				if err := s.CurrentBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_balance\"")
			}
		case "current_balance_date":
			if err := func() error {
				s.CurrentBalanceDate.Reset()
				if err := s.CurrentBalanceDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_balance_date\"")
			}
		case "iban":
			if err := func() error {
				s.Iban.Reset()
				if err := s.Iban.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iban\"")
			}
		case "bic":
			if err := func() error {
				s.Bic.Reset()
				if err := s.Bic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bic\"")
			}
		case "account_number":
			if err := func() error {
				s.AccountNumber.Reset()
				if err := s.AccountNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_number\"")
			}
		case "opening_balance":
			if err := func() error {
				s.OpeningBalance.Reset()
				if err := s.OpeningBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opening_balance\"")
			}
		case "current_debt":
			if err := func() error {
				s.CurrentDebt.Reset()
				if err := s.CurrentDebt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_debt\"")
			}
		case "opening_balance_date":
			if err := func() error {
				s.OpeningBalanceDate.Reset()
				if err := s.OpeningBalanceDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opening_balance_date\"")
			}
		case "virtual_balance":
			if err := func() error {
				s.VirtualBalance.Reset()
				if err := s.VirtualBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"virtual_balance\"")
			}
		case "include_net_worth":
			if err := func() error {
				s.IncludeNetWorth.Reset()
				if err := s.IncludeNetWorth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_net_worth\"")
			}
		case "credit_card_type":
			if err := func() error {
				s.CreditCardType.Reset()
				if err := s.CreditCardType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credit_card_type\"")
			}
		case "monthly_payment_date":
			if err := func() error {
				s.MonthlyPaymentDate.Reset()
				if err := s.MonthlyPaymentDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monthly_payment_date\"")
			}
		case "liability_type":
			if err := func() error {
				s.LiabilityType.Reset()
				if err := s.LiabilityType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"liability_type\"")
			}
		case "liability_direction":
			if err := func() error {
				s.LiabilityDirection.Reset()
				if err := s.LiabilityDirection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"liability_direction\"")
			}
		case "interest":
			if err := func() error {
				s.Interest.Reset()
				if err := s.Interest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interest\"")
			}
		case "interest_period":
			if err := func() error {
				s.InterestPeriod.Reset()
				if err := s.InterestPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interest_period\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "latitude":
			if err := func() error {
				s.Latitude.Reset()
				if err := s.Latitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			if err := func() error {
				s.Longitude.Reset()
				if err := s.Longitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "zoom_level":
			if err := func() error {
				s.ZoomLevel.Reset()
				if err := s.ZoomLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zoom_level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Account")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccount) {
					name = jsonFieldsNameOfAccount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Account) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Account) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccountArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccountArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
}

var jsonFieldsNameOfAccountArray = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes AccountArray from json.
func (s *AccountArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]AccountRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AccountRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccountArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccountArray) {
					name = jsonFieldsNameOfAccountArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccountArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccountRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccountRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
}

var jsonFieldsNameOfAccountRead = [3]string{
	0: "type",
	1: "id",
	2: "attributes",
}

// Decode decodes AccountRead from json.
func (s *AccountRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccountRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccountRead) {
					name = jsonFieldsNameOfAccountRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccountRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountRoleProperty as json.
func (s AccountRoleProperty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AccountRoleProperty from json.
func (s *AccountRoleProperty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountRoleProperty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AccountRoleProperty(v) {
	case AccountRolePropertyDefaultAsset:
		*s = AccountRolePropertyDefaultAsset
	case AccountRolePropertySharedAsset:
		*s = AccountRolePropertySharedAsset
	case AccountRolePropertySavingAsset:
		*s = AccountRolePropertySavingAsset
	case AccountRolePropertyCcAsset:
		*s = AccountRolePropertyCcAsset
	case AccountRolePropertyCashWalletAsset:
		*s = AccountRolePropertyCashWalletAsset
	default:
		*s = AccountRoleProperty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccountRoleProperty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountRoleProperty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccountSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccountSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfAccountSingle = [1]string{
	0: "data",
}

// Decode decodes AccountSingle from json.
func (s *AccountSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccountSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccountSingle) {
					name = jsonFieldsNameOfAccountSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccountSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccountStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccountStore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Iban.Set {
			e.FieldStart("iban")
			s.Iban.Encode(e)
		}
	}
	{
		if s.Bic.Set {
			e.FieldStart("bic")
			s.Bic.Encode(e)
		}
	}
	{
		if s.AccountNumber.Set {
			e.FieldStart("account_number")
			s.AccountNumber.Encode(e)
		}
	}
	{
		if s.OpeningBalance.Set {
			e.FieldStart("opening_balance")
			s.OpeningBalance.Encode(e)
		}
	}
	{
		if s.OpeningBalanceDate.Set {
			e.FieldStart("opening_balance_date")
			s.OpeningBalanceDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.VirtualBalance.Set {
			e.FieldStart("virtual_balance")
			s.VirtualBalance.Encode(e)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.IncludeNetWorth.Set {
			e.FieldStart("include_net_worth")
			s.IncludeNetWorth.Encode(e)
		}
	}
	{
		if s.AccountRole.Set {
			e.FieldStart("account_role")
			s.AccountRole.Encode(e)
		}
	}
	{
		if s.CreditCardType.Set {
			e.FieldStart("credit_card_type")
			s.CreditCardType.Encode(e)
		}
	}
	{
		if s.MonthlyPaymentDate.Set {
			e.FieldStart("monthly_payment_date")
			s.MonthlyPaymentDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LiabilityType.Set {
			e.FieldStart("liability_type")
			s.LiabilityType.Encode(e)
		}
	}
	{
		if s.LiabilityDirection.Set {
			e.FieldStart("liability_direction")
			s.LiabilityDirection.Encode(e)
		}
	}
	{
		if s.Interest.Set {
			e.FieldStart("interest")
			s.Interest.Encode(e)
		}
	}
	{
		if s.InterestPeriod.Set {
			e.FieldStart("interest_period")
			s.InterestPeriod.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.Latitude.Set {
			e.FieldStart("latitude")
			s.Latitude.Encode(e)
		}
	}
	{
		if s.Longitude.Set {
			e.FieldStart("longitude")
			s.Longitude.Encode(e)
		}
	}
	{
		if s.ZoomLevel.Set {
			e.FieldStart("zoom_level")
			s.ZoomLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfAccountStore = [24]string{
	0:  "name",
	1:  "type",
	2:  "iban",
	3:  "bic",
	4:  "account_number",
	5:  "opening_balance",
	6:  "opening_balance_date",
	7:  "virtual_balance",
	8:  "currency_id",
	9:  "currency_code",
	10: "active",
	11: "order",
	12: "include_net_worth",
	13: "account_role",
	14: "credit_card_type",
	15: "monthly_payment_date",
	16: "liability_type",
	17: "liability_direction",
	18: "interest",
	19: "interest_period",
	20: "notes",
	21: "latitude",
	22: "longitude",
	23: "zoom_level",
}

// Decode decodes AccountStore from json.
func (s *AccountStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountStore to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "iban":
			if err := func() error {
				s.Iban.Reset()
				if err := s.Iban.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iban\"")
			}
		case "bic":
			if err := func() error {
				s.Bic.Reset()
				if err := s.Bic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bic\"")
			}
		case "account_number":
			if err := func() error {
				s.AccountNumber.Reset()
				if err := s.AccountNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_number\"")
			}
		case "opening_balance":
			if err := func() error {
				s.OpeningBalance.Reset()
				if err := s.OpeningBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opening_balance\"")
			}
		case "opening_balance_date":
			if err := func() error {
				s.OpeningBalanceDate.Reset()
				if err := s.OpeningBalanceDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opening_balance_date\"")
			}
		case "virtual_balance":
			if err := func() error {
				s.VirtualBalance.Reset()
				if err := s.VirtualBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"virtual_balance\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "include_net_worth":
			if err := func() error {
				s.IncludeNetWorth.Reset()
				if err := s.IncludeNetWorth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_net_worth\"")
			}
		case "account_role":
			if err := func() error {
				s.AccountRole.Reset()
				if err := s.AccountRole.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_role\"")
			}
		case "credit_card_type":
			if err := func() error {
				s.CreditCardType.Reset()
				if err := s.CreditCardType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credit_card_type\"")
			}
		case "monthly_payment_date":
			if err := func() error {
				s.MonthlyPaymentDate.Reset()
				if err := s.MonthlyPaymentDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monthly_payment_date\"")
			}
		case "liability_type":
			if err := func() error {
				s.LiabilityType.Reset()
				if err := s.LiabilityType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"liability_type\"")
			}
		case "liability_direction":
			if err := func() error {
				s.LiabilityDirection.Reset()
				if err := s.LiabilityDirection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"liability_direction\"")
			}
		case "interest":
			if err := func() error {
				s.Interest.Reset()
				if err := s.Interest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interest\"")
			}
		case "interest_period":
			if err := func() error {
				s.InterestPeriod.Reset()
				if err := s.InterestPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interest_period\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "latitude":
			if err := func() error {
				s.Latitude.Reset()
				if err := s.Latitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			if err := func() error {
				s.Longitude.Reset()
				if err := s.Longitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "zoom_level":
			if err := func() error {
				s.ZoomLevel.Reset()
				if err := s.ZoomLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zoom_level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccountStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000011,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccountStore) {
					name = jsonFieldsNameOfAccountStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccountStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountTypeProperty as json.
func (s AccountTypeProperty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AccountTypeProperty from json.
func (s *AccountTypeProperty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountTypeProperty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AccountTypeProperty(v) {
	case AccountTypePropertyDefaultAccount:
		*s = AccountTypePropertyDefaultAccount
	case AccountTypePropertyCashAccount:
		*s = AccountTypePropertyCashAccount
	case AccountTypePropertyAssetAccount:
		*s = AccountTypePropertyAssetAccount
	case AccountTypePropertyExpenseAccount:
		*s = AccountTypePropertyExpenseAccount
	case AccountTypePropertyRevenueAccount:
		*s = AccountTypePropertyRevenueAccount
	case AccountTypePropertyInitialBalanceAccount:
		*s = AccountTypePropertyInitialBalanceAccount
	case AccountTypePropertyBeneficiaryAccount:
		*s = AccountTypePropertyBeneficiaryAccount
	case AccountTypePropertyImportAccount:
		*s = AccountTypePropertyImportAccount
	case AccountTypePropertyReconciliationAccount:
		*s = AccountTypePropertyReconciliationAccount
	case AccountTypePropertyLoan:
		*s = AccountTypePropertyLoan
	case AccountTypePropertyDebt:
		*s = AccountTypePropertyDebt
	case AccountTypePropertyMortgage:
		*s = AccountTypePropertyMortgage
	default:
		*s = AccountTypeProperty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccountTypeProperty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountTypeProperty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccountUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccountUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Iban.Set {
			e.FieldStart("iban")
			s.Iban.Encode(e)
		}
	}
	{
		if s.Bic.Set {
			e.FieldStart("bic")
			s.Bic.Encode(e)
		}
	}
	{
		if s.AccountNumber.Set {
			e.FieldStart("account_number")
			s.AccountNumber.Encode(e)
		}
	}
	{
		if s.OpeningBalance.Set {
			e.FieldStart("opening_balance")
			s.OpeningBalance.Encode(e)
		}
	}
	{
		if s.OpeningBalanceDate.Set {
			e.FieldStart("opening_balance_date")
			s.OpeningBalanceDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.VirtualBalance.Set {
			e.FieldStart("virtual_balance")
			s.VirtualBalance.Encode(e)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.IncludeNetWorth.Set {
			e.FieldStart("include_net_worth")
			s.IncludeNetWorth.Encode(e)
		}
	}
	{
		if s.AccountRole.Set {
			e.FieldStart("account_role")
			s.AccountRole.Encode(e)
		}
	}
	{
		if s.CreditCardType.Set {
			e.FieldStart("credit_card_type")
			s.CreditCardType.Encode(e)
		}
	}
	{
		if s.MonthlyPaymentDate.Set {
			e.FieldStart("monthly_payment_date")
			s.MonthlyPaymentDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LiabilityType.Set {
			e.FieldStart("liability_type")
			s.LiabilityType.Encode(e)
		}
	}
	{
		if s.Interest.Set {
			e.FieldStart("interest")
			s.Interest.Encode(e)
		}
	}
	{
		if s.InterestPeriod.Set {
			e.FieldStart("interest_period")
			s.InterestPeriod.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.Latitude.Set {
			e.FieldStart("latitude")
			s.Latitude.Encode(e)
		}
	}
	{
		if s.Longitude.Set {
			e.FieldStart("longitude")
			s.Longitude.Encode(e)
		}
	}
	{
		if s.ZoomLevel.Set {
			e.FieldStart("zoom_level")
			s.ZoomLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfAccountUpdate = [22]string{
	0:  "name",
	1:  "iban",
	2:  "bic",
	3:  "account_number",
	4:  "opening_balance",
	5:  "opening_balance_date",
	6:  "virtual_balance",
	7:  "currency_id",
	8:  "currency_code",
	9:  "active",
	10: "order",
	11: "include_net_worth",
	12: "account_role",
	13: "credit_card_type",
	14: "monthly_payment_date",
	15: "liability_type",
	16: "interest",
	17: "interest_period",
	18: "notes",
	19: "latitude",
	20: "longitude",
	21: "zoom_level",
}

// Decode decodes AccountUpdate from json.
func (s *AccountUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccountUpdate to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "iban":
			if err := func() error {
				s.Iban.Reset()
				if err := s.Iban.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iban\"")
			}
		case "bic":
			if err := func() error {
				s.Bic.Reset()
				if err := s.Bic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bic\"")
			}
		case "account_number":
			if err := func() error {
				s.AccountNumber.Reset()
				if err := s.AccountNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_number\"")
			}
		case "opening_balance":
			if err := func() error {
				s.OpeningBalance.Reset()
				if err := s.OpeningBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opening_balance\"")
			}
		case "opening_balance_date":
			if err := func() error {
				s.OpeningBalanceDate.Reset()
				if err := s.OpeningBalanceDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opening_balance_date\"")
			}
		case "virtual_balance":
			if err := func() error {
				s.VirtualBalance.Reset()
				if err := s.VirtualBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"virtual_balance\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "include_net_worth":
			if err := func() error {
				s.IncludeNetWorth.Reset()
				if err := s.IncludeNetWorth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_net_worth\"")
			}
		case "account_role":
			if err := func() error {
				s.AccountRole.Reset()
				if err := s.AccountRole.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_role\"")
			}
		case "credit_card_type":
			if err := func() error {
				s.CreditCardType.Reset()
				if err := s.CreditCardType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credit_card_type\"")
			}
		case "monthly_payment_date":
			if err := func() error {
				s.MonthlyPaymentDate.Reset()
				if err := s.MonthlyPaymentDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monthly_payment_date\"")
			}
		case "liability_type":
			if err := func() error {
				s.LiabilityType.Reset()
				if err := s.LiabilityType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"liability_type\"")
			}
		case "interest":
			if err := func() error {
				s.Interest.Reset()
				if err := s.Interest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interest\"")
			}
		case "interest_period":
			if err := func() error {
				s.InterestPeriod.Reset()
				if err := s.InterestPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interest_period\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "latitude":
			if err := func() error {
				s.Latitude.Reset()
				if err := s.Latitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			if err := func() error {
				s.Longitude.Reset()
				if err := s.Longitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "zoom_level":
			if err := func() error {
				s.ZoomLevel.Reset()
				if err := s.ZoomLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zoom_level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccountUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAccountUpdate) {
					name = jsonFieldsNameOfAccountUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccountUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccountUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AttachableType as json.
func (s AttachableType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AttachableType from json.
func (s *AttachableType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttachableType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AttachableType(v) {
	case AttachableTypeAccount:
		*s = AttachableTypeAccount
	case AttachableTypeBudget:
		*s = AttachableTypeBudget
	case AttachableTypeBill:
		*s = AttachableTypeBill
	case AttachableTypeTransactionJournal:
		*s = AttachableTypeTransactionJournal
	case AttachableTypePiggyBank:
		*s = AttachableTypePiggyBank
	case AttachableTypeTag:
		*s = AttachableTypeTag
	default:
		*s = AttachableType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AttachableType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttachableType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Attachment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Attachment) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("attachable_type")
		s.AttachableType.Encode(e)
	}
	{
		e.FieldStart("attachable_id")
		e.Str(s.AttachableID)
	}
	{
		if s.MD5.Set {
			e.FieldStart("md5")
			s.MD5.Encode(e)
		}
	}
	{
		e.FieldStart("filename")
		e.Str(s.Filename)
	}
	{
		if s.DownloadURL.Set {
			e.FieldStart("download_url")
			s.DownloadURL.Encode(e)
		}
	}
	{
		if s.UploadURL.Set {
			e.FieldStart("upload_url")
			s.UploadURL.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.Mime.Set {
			e.FieldStart("mime")
			s.Mime.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
}

var jsonFieldsNameOfAttachment = [12]string{
	0:  "created_at",
	1:  "updated_at",
	2:  "attachable_type",
	3:  "attachable_id",
	4:  "md5",
	5:  "filename",
	6:  "download_url",
	7:  "upload_url",
	8:  "title",
	9:  "notes",
	10: "mime",
	11: "size",
}

// Decode decodes Attachment from json.
func (s *Attachment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Attachment to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "attachable_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.AttachableType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attachable_type\"")
			}
		case "attachable_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.AttachableID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attachable_id\"")
			}
		case "md5":
			if err := func() error {
				s.MD5.Reset()
				if err := s.MD5.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"md5\"")
			}
		case "filename":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Filename = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "download_url":
			if err := func() error {
				s.DownloadURL.Reset()
				if err := s.DownloadURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download_url\"")
			}
		case "upload_url":
			if err := func() error {
				s.UploadURL.Reset()
				if err := s.UploadURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upload_url\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "mime":
			if err := func() error {
				s.Mime.Reset()
				if err := s.Mime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Attachment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00101100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAttachment) {
					name = jsonFieldsNameOfAttachment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Attachment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Attachment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AttachmentArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AttachmentArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
}

var jsonFieldsNameOfAttachmentArray = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes AttachmentArray from json.
func (s *AttachmentArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttachmentArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]AttachmentRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AttachmentRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AttachmentArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAttachmentArray) {
					name = jsonFieldsNameOfAttachmentArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AttachmentArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttachmentArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AttachmentRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AttachmentRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfAttachmentRead = [4]string{
	0: "type",
	1: "id",
	2: "attributes",
	3: "links",
}

// Decode decodes AttachmentRead from json.
func (s *AttachmentRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttachmentRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AttachmentRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAttachmentRead) {
					name = jsonFieldsNameOfAttachmentRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AttachmentRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttachmentRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AttachmentSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AttachmentSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfAttachmentSingle = [1]string{
	0: "data",
}

// Decode decodes AttachmentSingle from json.
func (s *AttachmentSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttachmentSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AttachmentSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAttachmentSingle) {
					name = jsonFieldsNameOfAttachmentSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AttachmentSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttachmentSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AttachmentStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AttachmentStore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("filename")
		e.Str(s.Filename)
	}
	{
		e.FieldStart("attachable_type")
		s.AttachableType.Encode(e)
	}
	{
		e.FieldStart("attachable_id")
		e.Str(s.AttachableID)
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
}

var jsonFieldsNameOfAttachmentStore = [5]string{
	0: "filename",
	1: "attachable_type",
	2: "attachable_id",
	3: "title",
	4: "notes",
}

// Decode decodes AttachmentStore from json.
func (s *AttachmentStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttachmentStore to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "filename":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Filename = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "attachable_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AttachableType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attachable_type\"")
			}
		case "attachable_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AttachableID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attachable_id\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AttachmentStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAttachmentStore) {
					name = jsonFieldsNameOfAttachmentStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AttachmentStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttachmentStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AttachmentUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AttachmentUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Filename.Set {
			e.FieldStart("filename")
			s.Filename.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
}

var jsonFieldsNameOfAttachmentUpdate = [3]string{
	0: "filename",
	1: "title",
	2: "notes",
}

// Decode decodes AttachmentUpdate from json.
func (s *AttachmentUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttachmentUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "filename":
			if err := func() error {
				s.Filename.Reset()
				if err := s.Filename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AttachmentUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AttachmentUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttachmentUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutoBudgetPeriod as json.
func (s AutoBudgetPeriod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AutoBudgetPeriod from json.
func (s *AutoBudgetPeriod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutoBudgetPeriod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AutoBudgetPeriod(v) {
	case AutoBudgetPeriodDaily:
		*s = AutoBudgetPeriodDaily
	case AutoBudgetPeriodWeekly:
		*s = AutoBudgetPeriodWeekly
	case AutoBudgetPeriodMonthly:
		*s = AutoBudgetPeriodMonthly
	case AutoBudgetPeriodQuarterly:
		*s = AutoBudgetPeriodQuarterly
	case AutoBudgetPeriodHalfYear:
		*s = AutoBudgetPeriodHalfYear
	case AutoBudgetPeriodYearly:
		*s = AutoBudgetPeriodYearly
	default:
		*s = AutoBudgetPeriod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutoBudgetPeriod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutoBudgetPeriod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutoBudgetType as json.
func (s AutoBudgetType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AutoBudgetType from json.
func (s *AutoBudgetType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutoBudgetType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AutoBudgetType(v) {
	case AutoBudgetTypeReset:
		*s = AutoBudgetTypeReset
	case AutoBudgetTypeRollover:
		*s = AutoBudgetTypeRollover
	case AutoBudgetTypeNone:
		*s = AutoBudgetTypeNone
	default:
		*s = AutoBudgetType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutoBudgetType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutoBudgetType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutocompleteAccount) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutocompleteAccount) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("name_with_balance")
		e.Str(s.NameWithBalance)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("currency_id")
		e.Str(s.CurrencyID)
	}
	{
		e.FieldStart("currency_name")
		e.Str(s.CurrencyName)
	}
	{
		e.FieldStart("currency_code")
		e.Str(s.CurrencyCode)
	}
	{
		e.FieldStart("currency_symbol")
		e.Str(s.CurrencySymbol)
	}
	{
		e.FieldStart("currency_decimal_places")
		e.Int32(s.CurrencyDecimalPlaces)
	}
}

var jsonFieldsNameOfAutocompleteAccount = [9]string{
	0: "id",
	1: "name",
	2: "name_with_balance",
	3: "type",
	4: "currency_id",
	5: "currency_name",
	6: "currency_code",
	7: "currency_symbol",
	8: "currency_decimal_places",
}

// Decode decodes AutocompleteAccount from json.
func (s *AutocompleteAccount) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteAccount to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "name_with_balance":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NameWithBalance = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name_with_balance\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "currency_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CurrencyID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CurrencyName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_name\"")
			}
		case "currency_code":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CurrencyCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "currency_symbol":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.CurrencySymbol = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_symbol\"")
			}
		case "currency_decimal_places":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.CurrencyDecimalPlaces = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_decimal_places\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutocompleteAccount")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutocompleteAccount) {
					name = jsonFieldsNameOfAutocompleteAccount[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutocompleteAccount) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteAccount) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutocompleteAccountArray as json.
func (s AutocompleteAccountArray) Encode(e *jx.Encoder) {
	unwrapped := []AutocompleteAccount(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AutocompleteAccountArray from json.
func (s *AutocompleteAccountArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteAccountArray to nil")
	}
	var unwrapped []AutocompleteAccount
	if err := func() error {
		unwrapped = make([]AutocompleteAccount, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AutocompleteAccount
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutocompleteAccountArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutocompleteAccountArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteAccountArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutocompleteBill) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutocompleteBill) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
}

var jsonFieldsNameOfAutocompleteBill = [3]string{
	0: "id",
	1: "name",
	2: "active",
}

// Decode decodes AutocompleteBill from json.
func (s *AutocompleteBill) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteBill to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutocompleteBill")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutocompleteBill) {
					name = jsonFieldsNameOfAutocompleteBill[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutocompleteBill) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteBill) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutocompleteBillArray as json.
func (s AutocompleteBillArray) Encode(e *jx.Encoder) {
	unwrapped := []AutocompleteBill(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AutocompleteBillArray from json.
func (s *AutocompleteBillArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteBillArray to nil")
	}
	var unwrapped []AutocompleteBill
	if err := func() error {
		unwrapped = make([]AutocompleteBill, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AutocompleteBill
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutocompleteBillArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutocompleteBillArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteBillArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutocompleteBudget) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutocompleteBudget) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfAutocompleteBudget = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes AutocompleteBudget from json.
func (s *AutocompleteBudget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteBudget to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutocompleteBudget")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutocompleteBudget) {
					name = jsonFieldsNameOfAutocompleteBudget[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutocompleteBudget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteBudget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutocompleteBudgetArray as json.
func (s AutocompleteBudgetArray) Encode(e *jx.Encoder) {
	unwrapped := []AutocompleteBudget(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AutocompleteBudgetArray from json.
func (s *AutocompleteBudgetArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteBudgetArray to nil")
	}
	var unwrapped []AutocompleteBudget
	if err := func() error {
		unwrapped = make([]AutocompleteBudget, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AutocompleteBudget
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutocompleteBudgetArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutocompleteBudgetArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteBudgetArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutocompleteCategory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutocompleteCategory) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfAutocompleteCategory = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes AutocompleteCategory from json.
func (s *AutocompleteCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteCategory to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutocompleteCategory")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutocompleteCategory) {
					name = jsonFieldsNameOfAutocompleteCategory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutocompleteCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutocompleteCategoryArray as json.
func (s AutocompleteCategoryArray) Encode(e *jx.Encoder) {
	unwrapped := []AutocompleteCategory(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AutocompleteCategoryArray from json.
func (s *AutocompleteCategoryArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteCategoryArray to nil")
	}
	var unwrapped []AutocompleteCategory
	if err := func() error {
		unwrapped = make([]AutocompleteCategory, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AutocompleteCategory
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutocompleteCategoryArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutocompleteCategoryArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteCategoryArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutocompleteCurrency) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutocompleteCurrency) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("symbol")
		e.Str(s.Symbol)
	}
	{
		e.FieldStart("decimal_places")
		e.Int32(s.DecimalPlaces)
	}
}

var jsonFieldsNameOfAutocompleteCurrency = [5]string{
	0: "id",
	1: "name",
	2: "code",
	3: "symbol",
	4: "decimal_places",
}

// Decode decodes AutocompleteCurrency from json.
func (s *AutocompleteCurrency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteCurrency to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "symbol":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Symbol = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbol\"")
			}
		case "decimal_places":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.DecimalPlaces = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decimal_places\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutocompleteCurrency")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutocompleteCurrency) {
					name = jsonFieldsNameOfAutocompleteCurrency[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutocompleteCurrency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteCurrency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutocompleteCurrencyArray as json.
func (s AutocompleteCurrencyArray) Encode(e *jx.Encoder) {
	unwrapped := []AutocompleteCurrency(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AutocompleteCurrencyArray from json.
func (s *AutocompleteCurrencyArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteCurrencyArray to nil")
	}
	var unwrapped []AutocompleteCurrency
	if err := func() error {
		unwrapped = make([]AutocompleteCurrency, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AutocompleteCurrency
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutocompleteCurrencyArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutocompleteCurrencyArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteCurrencyArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutocompleteCurrencyCode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutocompleteCurrencyCode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("symbol")
		e.Str(s.Symbol)
	}
	{
		e.FieldStart("decimal_places")
		e.Int32(s.DecimalPlaces)
	}
}

var jsonFieldsNameOfAutocompleteCurrencyCode = [5]string{
	0: "id",
	1: "name",
	2: "code",
	3: "symbol",
	4: "decimal_places",
}

// Decode decodes AutocompleteCurrencyCode from json.
func (s *AutocompleteCurrencyCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteCurrencyCode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "symbol":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Symbol = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbol\"")
			}
		case "decimal_places":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.DecimalPlaces = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decimal_places\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutocompleteCurrencyCode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutocompleteCurrencyCode) {
					name = jsonFieldsNameOfAutocompleteCurrencyCode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutocompleteCurrencyCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteCurrencyCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutocompleteCurrencyCodeArray as json.
func (s AutocompleteCurrencyCodeArray) Encode(e *jx.Encoder) {
	unwrapped := []AutocompleteCurrencyCode(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AutocompleteCurrencyCodeArray from json.
func (s *AutocompleteCurrencyCodeArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteCurrencyCodeArray to nil")
	}
	var unwrapped []AutocompleteCurrencyCode
	if err := func() error {
		unwrapped = make([]AutocompleteCurrencyCode, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AutocompleteCurrencyCode
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutocompleteCurrencyCodeArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutocompleteCurrencyCodeArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteCurrencyCodeArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutocompleteObjectGroup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutocompleteObjectGroup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfAutocompleteObjectGroup = [3]string{
	0: "id",
	1: "title",
	2: "name",
}

// Decode decodes AutocompleteObjectGroup from json.
func (s *AutocompleteObjectGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteObjectGroup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutocompleteObjectGroup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutocompleteObjectGroup) {
					name = jsonFieldsNameOfAutocompleteObjectGroup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutocompleteObjectGroup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteObjectGroup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutocompleteObjectGroupArray as json.
func (s AutocompleteObjectGroupArray) Encode(e *jx.Encoder) {
	unwrapped := []AutocompleteObjectGroup(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AutocompleteObjectGroupArray from json.
func (s *AutocompleteObjectGroupArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteObjectGroupArray to nil")
	}
	var unwrapped []AutocompleteObjectGroup
	if err := func() error {
		unwrapped = make([]AutocompleteObjectGroup, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AutocompleteObjectGroup
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutocompleteObjectGroupArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutocompleteObjectGroupArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteObjectGroupArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutocompletePiggy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutocompletePiggy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.CurrencySymbol.Set {
			e.FieldStart("currency_symbol")
			s.CurrencySymbol.Encode(e)
		}
	}
	{
		if s.CurrencyName.Set {
			e.FieldStart("currency_name")
			s.CurrencyName.Encode(e)
		}
	}
	{
		if s.CurrencyDecimalPlaces.Set {
			e.FieldStart("currency_decimal_places")
			s.CurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		if s.ObjectGroupID.Set {
			e.FieldStart("object_group_id")
			s.ObjectGroupID.Encode(e)
		}
	}
	{
		if s.ObjectGroupTitle.Set {
			e.FieldStart("object_group_title")
			s.ObjectGroupTitle.Encode(e)
		}
	}
}

var jsonFieldsNameOfAutocompletePiggy = [9]string{
	0: "id",
	1: "name",
	2: "currency_id",
	3: "currency_code",
	4: "currency_symbol",
	5: "currency_name",
	6: "currency_decimal_places",
	7: "object_group_id",
	8: "object_group_title",
}

// Decode decodes AutocompletePiggy from json.
func (s *AutocompletePiggy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompletePiggy to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "currency_symbol":
			if err := func() error {
				s.CurrencySymbol.Reset()
				if err := s.CurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_symbol\"")
			}
		case "currency_name":
			if err := func() error {
				s.CurrencyName.Reset()
				if err := s.CurrencyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_name\"")
			}
		case "currency_decimal_places":
			if err := func() error {
				s.CurrencyDecimalPlaces.Reset()
				if err := s.CurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_decimal_places\"")
			}
		case "object_group_id":
			if err := func() error {
				s.ObjectGroupID.Reset()
				if err := s.ObjectGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_id\"")
			}
		case "object_group_title":
			if err := func() error {
				s.ObjectGroupTitle.Reset()
				if err := s.ObjectGroupTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutocompletePiggy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutocompletePiggy) {
					name = jsonFieldsNameOfAutocompletePiggy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutocompletePiggy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompletePiggy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutocompletePiggyArray as json.
func (s AutocompletePiggyArray) Encode(e *jx.Encoder) {
	unwrapped := []AutocompletePiggy(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AutocompletePiggyArray from json.
func (s *AutocompletePiggyArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompletePiggyArray to nil")
	}
	var unwrapped []AutocompletePiggy
	if err := func() error {
		unwrapped = make([]AutocompletePiggy, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AutocompletePiggy
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutocompletePiggyArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutocompletePiggyArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompletePiggyArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutocompletePiggyBalance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutocompletePiggyBalance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.NameWithBalance.Set {
			e.FieldStart("name_with_balance")
			s.NameWithBalance.Encode(e)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.CurrencySymbol.Set {
			e.FieldStart("currency_symbol")
			s.CurrencySymbol.Encode(e)
		}
	}
	{
		if s.CurrencyDecimalPlaces.Set {
			e.FieldStart("currency_decimal_places")
			s.CurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		if s.ObjectGroupID.Set {
			e.FieldStart("object_group_id")
			s.ObjectGroupID.Encode(e)
		}
	}
	{
		if s.ObjectGroupTitle.Set {
			e.FieldStart("object_group_title")
			s.ObjectGroupTitle.Encode(e)
		}
	}
}

var jsonFieldsNameOfAutocompletePiggyBalance = [9]string{
	0: "id",
	1: "name",
	2: "name_with_balance",
	3: "currency_id",
	4: "currency_code",
	5: "currency_symbol",
	6: "currency_decimal_places",
	7: "object_group_id",
	8: "object_group_title",
}

// Decode decodes AutocompletePiggyBalance from json.
func (s *AutocompletePiggyBalance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompletePiggyBalance to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "name_with_balance":
			if err := func() error {
				s.NameWithBalance.Reset()
				if err := s.NameWithBalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name_with_balance\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "currency_symbol":
			if err := func() error {
				s.CurrencySymbol.Reset()
				if err := s.CurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_symbol\"")
			}
		case "currency_decimal_places":
			if err := func() error {
				s.CurrencyDecimalPlaces.Reset()
				if err := s.CurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_decimal_places\"")
			}
		case "object_group_id":
			if err := func() error {
				s.ObjectGroupID.Reset()
				if err := s.ObjectGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_id\"")
			}
		case "object_group_title":
			if err := func() error {
				s.ObjectGroupTitle.Reset()
				if err := s.ObjectGroupTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutocompletePiggyBalance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutocompletePiggyBalance) {
					name = jsonFieldsNameOfAutocompletePiggyBalance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutocompletePiggyBalance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompletePiggyBalance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutocompletePiggyBalanceArray as json.
func (s AutocompletePiggyBalanceArray) Encode(e *jx.Encoder) {
	unwrapped := []AutocompletePiggyBalance(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AutocompletePiggyBalanceArray from json.
func (s *AutocompletePiggyBalanceArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompletePiggyBalanceArray to nil")
	}
	var unwrapped []AutocompletePiggyBalance
	if err := func() error {
		unwrapped = make([]AutocompletePiggyBalance, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AutocompletePiggyBalance
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutocompletePiggyBalanceArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutocompletePiggyBalanceArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompletePiggyBalanceArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutocompleteRecurrence) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutocompleteRecurrence) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfAutocompleteRecurrence = [3]string{
	0: "id",
	1: "name",
	2: "description",
}

// Decode decodes AutocompleteRecurrence from json.
func (s *AutocompleteRecurrence) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteRecurrence to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutocompleteRecurrence")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutocompleteRecurrence) {
					name = jsonFieldsNameOfAutocompleteRecurrence[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutocompleteRecurrence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteRecurrence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutocompleteRecurrenceArray as json.
func (s AutocompleteRecurrenceArray) Encode(e *jx.Encoder) {
	unwrapped := []AutocompleteRecurrence(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AutocompleteRecurrenceArray from json.
func (s *AutocompleteRecurrenceArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteRecurrenceArray to nil")
	}
	var unwrapped []AutocompleteRecurrence
	if err := func() error {
		unwrapped = make([]AutocompleteRecurrence, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AutocompleteRecurrence
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutocompleteRecurrenceArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutocompleteRecurrenceArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteRecurrenceArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutocompleteRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutocompleteRule) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfAutocompleteRule = [3]string{
	0: "id",
	1: "name",
	2: "description",
}

// Decode decodes AutocompleteRule from json.
func (s *AutocompleteRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteRule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutocompleteRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutocompleteRule) {
					name = jsonFieldsNameOfAutocompleteRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutocompleteRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutocompleteRuleArray as json.
func (s AutocompleteRuleArray) Encode(e *jx.Encoder) {
	unwrapped := []AutocompleteRule(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AutocompleteRuleArray from json.
func (s *AutocompleteRuleArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteRuleArray to nil")
	}
	var unwrapped []AutocompleteRule
	if err := func() error {
		unwrapped = make([]AutocompleteRule, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AutocompleteRule
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutocompleteRuleArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutocompleteRuleArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteRuleArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutocompleteRuleGroup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutocompleteRuleGroup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfAutocompleteRuleGroup = [3]string{
	0: "id",
	1: "name",
	2: "description",
}

// Decode decodes AutocompleteRuleGroup from json.
func (s *AutocompleteRuleGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteRuleGroup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutocompleteRuleGroup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutocompleteRuleGroup) {
					name = jsonFieldsNameOfAutocompleteRuleGroup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutocompleteRuleGroup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteRuleGroup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutocompleteRuleGroupArray as json.
func (s AutocompleteRuleGroupArray) Encode(e *jx.Encoder) {
	unwrapped := []AutocompleteRuleGroup(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AutocompleteRuleGroupArray from json.
func (s *AutocompleteRuleGroupArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteRuleGroupArray to nil")
	}
	var unwrapped []AutocompleteRuleGroup
	if err := func() error {
		unwrapped = make([]AutocompleteRuleGroup, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AutocompleteRuleGroup
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutocompleteRuleGroupArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutocompleteRuleGroupArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteRuleGroupArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutocompleteTag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutocompleteTag) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
}

var jsonFieldsNameOfAutocompleteTag = [3]string{
	0: "id",
	1: "name",
	2: "tag",
}

// Decode decodes AutocompleteTag from json.
func (s *AutocompleteTag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteTag to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutocompleteTag")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutocompleteTag) {
					name = jsonFieldsNameOfAutocompleteTag[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutocompleteTag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteTag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutocompleteTagArray as json.
func (s AutocompleteTagArray) Encode(e *jx.Encoder) {
	unwrapped := []AutocompleteTag(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AutocompleteTagArray from json.
func (s *AutocompleteTagArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteTagArray to nil")
	}
	var unwrapped []AutocompleteTag
	if err := func() error {
		unwrapped = make([]AutocompleteTag, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AutocompleteTag
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutocompleteTagArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutocompleteTagArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteTagArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutocompleteTransaction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutocompleteTransaction) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.TransactionGroupID.Set {
			e.FieldStart("transaction_group_id")
			s.TransactionGroupID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfAutocompleteTransaction = [4]string{
	0: "id",
	1: "transaction_group_id",
	2: "name",
	3: "description",
}

// Decode decodes AutocompleteTransaction from json.
func (s *AutocompleteTransaction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteTransaction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "transaction_group_id":
			if err := func() error {
				s.TransactionGroupID.Reset()
				if err := s.TransactionGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transaction_group_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutocompleteTransaction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutocompleteTransaction) {
					name = jsonFieldsNameOfAutocompleteTransaction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutocompleteTransaction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteTransaction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutocompleteTransactionArray as json.
func (s AutocompleteTransactionArray) Encode(e *jx.Encoder) {
	unwrapped := []AutocompleteTransaction(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AutocompleteTransactionArray from json.
func (s *AutocompleteTransactionArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteTransactionArray to nil")
	}
	var unwrapped []AutocompleteTransaction
	if err := func() error {
		unwrapped = make([]AutocompleteTransaction, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AutocompleteTransaction
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutocompleteTransactionArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutocompleteTransactionArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteTransactionArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutocompleteTransactionID) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutocompleteTransactionID) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.TransactionGroupID.Set {
			e.FieldStart("transaction_group_id")
			s.TransactionGroupID.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfAutocompleteTransactionID = [4]string{
	0: "id",
	1: "transaction_group_id",
	2: "name",
	3: "description",
}

// Decode decodes AutocompleteTransactionID from json.
func (s *AutocompleteTransactionID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteTransactionID to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "transaction_group_id":
			if err := func() error {
				s.TransactionGroupID.Reset()
				if err := s.TransactionGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transaction_group_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutocompleteTransactionID")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutocompleteTransactionID) {
					name = jsonFieldsNameOfAutocompleteTransactionID[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutocompleteTransactionID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteTransactionID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutocompleteTransactionIDArray as json.
func (s AutocompleteTransactionIDArray) Encode(e *jx.Encoder) {
	unwrapped := []AutocompleteTransactionID(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AutocompleteTransactionIDArray from json.
func (s *AutocompleteTransactionIDArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteTransactionIDArray to nil")
	}
	var unwrapped []AutocompleteTransactionID
	if err := func() error {
		unwrapped = make([]AutocompleteTransactionID, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AutocompleteTransactionID
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutocompleteTransactionIDArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutocompleteTransactionIDArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteTransactionIDArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutocompleteTransactionType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutocompleteTransactionType) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfAutocompleteTransactionType = [3]string{
	0: "id",
	1: "name",
	2: "type",
}

// Decode decodes AutocompleteTransactionType from json.
func (s *AutocompleteTransactionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteTransactionType to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutocompleteTransactionType")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutocompleteTransactionType) {
					name = jsonFieldsNameOfAutocompleteTransactionType[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutocompleteTransactionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteTransactionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutocompleteTransactionTypeArray as json.
func (s AutocompleteTransactionTypeArray) Encode(e *jx.Encoder) {
	unwrapped := []AutocompleteTransactionType(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AutocompleteTransactionTypeArray from json.
func (s *AutocompleteTransactionTypeArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutocompleteTransactionTypeArray to nil")
	}
	var unwrapped []AutocompleteTransactionType
	if err := func() error {
		unwrapped = make([]AutocompleteTransactionType, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AutocompleteTransactionType
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutocompleteTransactionTypeArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutocompleteTransactionTypeArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutocompleteTransactionTypeArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AvailableBudget) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AvailableBudget) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.CurrencySymbol.Set {
			e.FieldStart("currency_symbol")
			s.CurrencySymbol.Encode(e)
		}
	}
	{
		if s.CurrencyDecimalPlaces.Set {
			e.FieldStart("currency_decimal_places")
			s.CurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		e.FieldStart("amount")
		e.Str(s.Amount)
	}
	{
		e.FieldStart("start")
		json.EncodeDateTime(e, s.Start)
	}
	{
		e.FieldStart("end")
		json.EncodeDateTime(e, s.End)
	}
	{
		if s.SpentInBudgets != nil {
			e.FieldStart("spent_in_budgets")
			e.ArrStart()
			for _, elem := range s.SpentInBudgets {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SpentOutsideBudget != nil {
			e.FieldStart("spent_outside_budget")
			e.ArrStart()
			for _, elem := range s.SpentOutsideBudget {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAvailableBudget = [11]string{
	0:  "created_at",
	1:  "updated_at",
	2:  "currency_id",
	3:  "currency_code",
	4:  "currency_symbol",
	5:  "currency_decimal_places",
	6:  "amount",
	7:  "start",
	8:  "end",
	9:  "spent_in_budgets",
	10: "spent_outside_budget",
}

// Decode decodes AvailableBudget from json.
func (s *AvailableBudget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AvailableBudget to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "currency_symbol":
			if err := func() error {
				s.CurrencySymbol.Reset()
				if err := s.CurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_symbol\"")
			}
		case "currency_decimal_places":
			if err := func() error {
				s.CurrencyDecimalPlaces.Reset()
				if err := s.CurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_decimal_places\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Amount = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "start":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Start = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.End = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "spent_in_budgets":
			if err := func() error {
				s.SpentInBudgets = make([]BudgetSpent, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BudgetSpent
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SpentInBudgets = append(s.SpentInBudgets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spent_in_budgets\"")
			}
		case "spent_outside_budget":
			if err := func() error {
				s.SpentOutsideBudget = make([]BudgetSpent, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BudgetSpent
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SpentOutsideBudget = append(s.SpentOutsideBudget, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spent_outside_budget\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AvailableBudget")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11000000,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAvailableBudget) {
					name = jsonFieldsNameOfAvailableBudget[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AvailableBudget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AvailableBudget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AvailableBudgetArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AvailableBudgetArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
}

var jsonFieldsNameOfAvailableBudgetArray = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes AvailableBudgetArray from json.
func (s *AvailableBudgetArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AvailableBudgetArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]AvailableBudgetRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AvailableBudgetRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AvailableBudgetArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAvailableBudgetArray) {
					name = jsonFieldsNameOfAvailableBudgetArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AvailableBudgetArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AvailableBudgetArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AvailableBudgetRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AvailableBudgetRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
}

var jsonFieldsNameOfAvailableBudgetRead = [3]string{
	0: "type",
	1: "id",
	2: "attributes",
}

// Decode decodes AvailableBudgetRead from json.
func (s *AvailableBudgetRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AvailableBudgetRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AvailableBudgetRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAvailableBudgetRead) {
					name = jsonFieldsNameOfAvailableBudgetRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AvailableBudgetRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AvailableBudgetRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AvailableBudgetSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AvailableBudgetSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfAvailableBudgetSingle = [1]string{
	0: "data",
}

// Decode decodes AvailableBudgetSingle from json.
func (s *AvailableBudgetSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AvailableBudgetSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AvailableBudgetSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAvailableBudgetSingle) {
					name = jsonFieldsNameOfAvailableBudgetSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AvailableBudgetSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AvailableBudgetSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Exception.Set {
			e.FieldStart("exception")
			s.Exception.Encode(e)
		}
	}
}

var jsonFieldsNameOfBadRequest = [2]string{
	0: "message",
	1: "exception",
}

// Decode decodes BadRequest from json.
func (s *BadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "exception":
			if err := func() error {
				s.Exception.Reset()
				if err := s.Exception.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exception\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s BasicSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s BasicSummary) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes BasicSummary from json.
func (s *BasicSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BasicSummary to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem BasicSummaryEntry
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BasicSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BasicSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BasicSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BasicSummaryEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BasicSummaryEntry) encodeFields(e *jx.Encoder) {
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.MonetaryValue.Set {
			e.FieldStart("monetary_value")
			s.MonetaryValue.Encode(e)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.CurrencySymbol.Set {
			e.FieldStart("currency_symbol")
			s.CurrencySymbol.Encode(e)
		}
	}
	{
		if s.CurrencyDecimalPlaces.Set {
			e.FieldStart("currency_decimal_places")
			s.CurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		if s.ValueParsed.Set {
			e.FieldStart("value_parsed")
			s.ValueParsed.Encode(e)
		}
	}
	{
		if s.LocalIcon.Set {
			e.FieldStart("local_icon")
			s.LocalIcon.Encode(e)
		}
	}
	{
		if s.SubTitle.Set {
			e.FieldStart("sub_title")
			s.SubTitle.Encode(e)
		}
	}
}

var jsonFieldsNameOfBasicSummaryEntry = [10]string{
	0: "key",
	1: "title",
	2: "monetary_value",
	3: "currency_id",
	4: "currency_code",
	5: "currency_symbol",
	6: "currency_decimal_places",
	7: "value_parsed",
	8: "local_icon",
	9: "sub_title",
}

// Decode decodes BasicSummaryEntry from json.
func (s *BasicSummaryEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BasicSummaryEntry to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "monetary_value":
			if err := func() error {
				s.MonetaryValue.Reset()
				if err := s.MonetaryValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monetary_value\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "currency_symbol":
			if err := func() error {
				s.CurrencySymbol.Reset()
				if err := s.CurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_symbol\"")
			}
		case "currency_decimal_places":
			if err := func() error {
				s.CurrencyDecimalPlaces.Reset()
				if err := s.CurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_decimal_places\"")
			}
		case "value_parsed":
			if err := func() error {
				s.ValueParsed.Reset()
				if err := s.ValueParsed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value_parsed\"")
			}
		case "local_icon":
			if err := func() error {
				s.LocalIcon.Reset()
				if err := s.LocalIcon.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"local_icon\"")
			}
		case "sub_title":
			if err := func() error {
				s.SubTitle.Reset()
				if err := s.SubTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sub_title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BasicSummaryEntry")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BasicSummaryEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BasicSummaryEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Bill) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Bill) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.CurrencySymbol.Set {
			e.FieldStart("currency_symbol")
			s.CurrencySymbol.Encode(e)
		}
	}
	{
		if s.CurrencyDecimalPlaces.Set {
			e.FieldStart("currency_decimal_places")
			s.CurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("amount_min")
		e.Str(s.AmountMin)
	}
	{
		e.FieldStart("amount_max")
		e.Str(s.AmountMax)
	}
	{
		e.FieldStart("date")
		json.EncodeDateTime(e, s.Date)
	}
	{
		if s.EndDate.Set {
			e.FieldStart("end_date")
			s.EndDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ExtensionDate.Set {
			e.FieldStart("extension_date")
			s.ExtensionDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("repeat_freq")
		s.RepeatFreq.Encode(e)
	}
	{
		if s.Skip.Set {
			e.FieldStart("skip")
			s.Skip.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.NextExpectedMatch.Set {
			e.FieldStart("next_expected_match")
			s.NextExpectedMatch.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.NextExpectedMatchDiff.Set {
			e.FieldStart("next_expected_match_diff")
			s.NextExpectedMatchDiff.Encode(e)
		}
	}
	{
		if s.ObjectGroupID.Set {
			e.FieldStart("object_group_id")
			s.ObjectGroupID.Encode(e)
		}
	}
	{
		if s.ObjectGroupOrder.Set {
			e.FieldStart("object_group_order")
			s.ObjectGroupOrder.Encode(e)
		}
	}
	{
		if s.ObjectGroupTitle.Set {
			e.FieldStart("object_group_title")
			s.ObjectGroupTitle.Encode(e)
		}
	}
	{
		if s.PayDates != nil {
			e.FieldStart("pay_dates")
			e.ArrStart()
			for _, elem := range s.PayDates {
				json.EncodeDateTime(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PaidDates != nil {
			e.FieldStart("paid_dates")
			e.ArrStart()
			for _, elem := range s.PaidDates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBill = [24]string{
	0:  "created_at",
	1:  "updated_at",
	2:  "currency_id",
	3:  "currency_code",
	4:  "currency_symbol",
	5:  "currency_decimal_places",
	6:  "name",
	7:  "amount_min",
	8:  "amount_max",
	9:  "date",
	10: "end_date",
	11: "extension_date",
	12: "repeat_freq",
	13: "skip",
	14: "active",
	15: "order",
	16: "notes",
	17: "next_expected_match",
	18: "next_expected_match_diff",
	19: "object_group_id",
	20: "object_group_order",
	21: "object_group_title",
	22: "pay_dates",
	23: "paid_dates",
}

// Decode decodes Bill from json.
func (s *Bill) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Bill to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "currency_symbol":
			if err := func() error {
				s.CurrencySymbol.Reset()
				if err := s.CurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_symbol\"")
			}
		case "currency_decimal_places":
			if err := func() error {
				s.CurrencyDecimalPlaces.Reset()
				if err := s.CurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_decimal_places\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "amount_min":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.AmountMin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount_min\"")
			}
		case "amount_max":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AmountMax = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount_max\"")
			}
		case "date":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Date = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "end_date":
			if err := func() error {
				s.EndDate.Reset()
				if err := s.EndDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_date\"")
			}
		case "extension_date":
			if err := func() error {
				s.ExtensionDate.Reset()
				if err := s.ExtensionDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extension_date\"")
			}
		case "repeat_freq":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.RepeatFreq.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repeat_freq\"")
			}
		case "skip":
			if err := func() error {
				s.Skip.Reset()
				if err := s.Skip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skip\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "next_expected_match":
			if err := func() error {
				s.NextExpectedMatch.Reset()
				if err := s.NextExpectedMatch.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_expected_match\"")
			}
		case "next_expected_match_diff":
			if err := func() error {
				s.NextExpectedMatchDiff.Reset()
				if err := s.NextExpectedMatchDiff.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_expected_match_diff\"")
			}
		case "object_group_id":
			if err := func() error {
				s.ObjectGroupID.Reset()
				if err := s.ObjectGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_id\"")
			}
		case "object_group_order":
			if err := func() error {
				s.ObjectGroupOrder.Reset()
				if err := s.ObjectGroupOrder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_order\"")
			}
		case "object_group_title":
			if err := func() error {
				s.ObjectGroupTitle.Reset()
				if err := s.ObjectGroupTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_title\"")
			}
		case "pay_dates":
			if err := func() error {
				s.PayDates = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem time.Time
					v, err := json.DecodeDateTime(d)
					elem = v
					if err != nil {
						return err
					}
					s.PayDates = append(s.PayDates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pay_dates\"")
			}
		case "paid_dates":
			if err := func() error {
				s.PaidDates = make([]BillPaidDatesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BillPaidDatesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PaidDates = append(s.PaidDates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paid_dates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Bill")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11000000,
		0b00010011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBill) {
					name = jsonFieldsNameOfBill[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Bill) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Bill) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BillArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BillArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
}

var jsonFieldsNameOfBillArray = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes BillArray from json.
func (s *BillArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BillArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]BillRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BillRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BillArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBillArray) {
					name = jsonFieldsNameOfBillArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BillArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BillArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BillPaidDatesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BillPaidDatesItem) encodeFields(e *jx.Encoder) {
	{
		if s.TransactionGroupID.Set {
			e.FieldStart("transaction_group_id")
			s.TransactionGroupID.Encode(e)
		}
	}
	{
		if s.TransactionJournalID.Set {
			e.FieldStart("transaction_journal_id")
			s.TransactionJournalID.Encode(e)
		}
	}
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfBillPaidDatesItem = [3]string{
	0: "transaction_group_id",
	1: "transaction_journal_id",
	2: "date",
}

// Decode decodes BillPaidDatesItem from json.
func (s *BillPaidDatesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BillPaidDatesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "transaction_group_id":
			if err := func() error {
				s.TransactionGroupID.Reset()
				if err := s.TransactionGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transaction_group_id\"")
			}
		case "transaction_journal_id":
			if err := func() error {
				s.TransactionJournalID.Reset()
				if err := s.TransactionJournalID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transaction_journal_id\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BillPaidDatesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BillPaidDatesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BillPaidDatesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BillRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BillRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
}

var jsonFieldsNameOfBillRead = [3]string{
	0: "type",
	1: "id",
	2: "attributes",
}

// Decode decodes BillRead from json.
func (s *BillRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BillRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BillRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBillRead) {
					name = jsonFieldsNameOfBillRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BillRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BillRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BillRepeatFrequency as json.
func (s BillRepeatFrequency) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BillRepeatFrequency from json.
func (s *BillRepeatFrequency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BillRepeatFrequency to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BillRepeatFrequency(v) {
	case BillRepeatFrequencyWeekly:
		*s = BillRepeatFrequencyWeekly
	case BillRepeatFrequencyMonthly:
		*s = BillRepeatFrequencyMonthly
	case BillRepeatFrequencyQuarterly:
		*s = BillRepeatFrequencyQuarterly
	case BillRepeatFrequencyHalfYear:
		*s = BillRepeatFrequencyHalfYear
	case BillRepeatFrequencyYearly:
		*s = BillRepeatFrequencyYearly
	default:
		*s = BillRepeatFrequency(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BillRepeatFrequency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BillRepeatFrequency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BillSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BillSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfBillSingle = [1]string{
	0: "data",
}

// Decode decodes BillSingle from json.
func (s *BillSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BillSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BillSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBillSingle) {
					name = jsonFieldsNameOfBillSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BillSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BillSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BillStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BillStore) encodeFields(e *jx.Encoder) {
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("amount_min")
		e.Str(s.AmountMin)
	}
	{
		e.FieldStart("amount_max")
		e.Str(s.AmountMax)
	}
	{
		e.FieldStart("date")
		json.EncodeDateTime(e, s.Date)
	}
	{
		if s.EndDate.Set {
			e.FieldStart("end_date")
			s.EndDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ExtensionDate.Set {
			e.FieldStart("extension_date")
			s.ExtensionDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("repeat_freq")
		s.RepeatFreq.Encode(e)
	}
	{
		if s.Skip.Set {
			e.FieldStart("skip")
			s.Skip.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.ObjectGroupID.Set {
			e.FieldStart("object_group_id")
			s.ObjectGroupID.Encode(e)
		}
	}
	{
		if s.ObjectGroupTitle.Set {
			e.FieldStart("object_group_title")
			s.ObjectGroupTitle.Encode(e)
		}
	}
}

var jsonFieldsNameOfBillStore = [14]string{
	0:  "currency_id",
	1:  "currency_code",
	2:  "name",
	3:  "amount_min",
	4:  "amount_max",
	5:  "date",
	6:  "end_date",
	7:  "extension_date",
	8:  "repeat_freq",
	9:  "skip",
	10: "active",
	11: "notes",
	12: "object_group_id",
	13: "object_group_title",
}

// Decode decodes BillStore from json.
func (s *BillStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BillStore to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "amount_min":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.AmountMin = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount_min\"")
			}
		case "amount_max":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.AmountMax = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount_max\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Date = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "end_date":
			if err := func() error {
				s.EndDate.Reset()
				if err := s.EndDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_date\"")
			}
		case "extension_date":
			if err := func() error {
				s.ExtensionDate.Reset()
				if err := s.ExtensionDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extension_date\"")
			}
		case "repeat_freq":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.RepeatFreq.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repeat_freq\"")
			}
		case "skip":
			if err := func() error {
				s.Skip.Reset()
				if err := s.Skip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skip\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "object_group_id":
			if err := func() error {
				s.ObjectGroupID.Reset()
				if err := s.ObjectGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_id\"")
			}
		case "object_group_title":
			if err := func() error {
				s.ObjectGroupTitle.Reset()
				if err := s.ObjectGroupTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BillStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111100,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBillStore) {
					name = jsonFieldsNameOfBillStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BillStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BillStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BillUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BillUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.AmountMin.Set {
			e.FieldStart("amount_min")
			s.AmountMin.Encode(e)
		}
	}
	{
		if s.AmountMax.Set {
			e.FieldStart("amount_max")
			s.AmountMax.Encode(e)
		}
	}
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EndDate.Set {
			e.FieldStart("end_date")
			s.EndDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ExtensionDate.Set {
			e.FieldStart("extension_date")
			s.ExtensionDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.RepeatFreq.Set {
			e.FieldStart("repeat_freq")
			s.RepeatFreq.Encode(e)
		}
	}
	{
		if s.Skip.Set {
			e.FieldStart("skip")
			s.Skip.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.ObjectGroupID.Set {
			e.FieldStart("object_group_id")
			s.ObjectGroupID.Encode(e)
		}
	}
	{
		if s.ObjectGroupTitle.Set {
			e.FieldStart("object_group_title")
			s.ObjectGroupTitle.Encode(e)
		}
	}
}

var jsonFieldsNameOfBillUpdate = [14]string{
	0:  "currency_id",
	1:  "currency_code",
	2:  "name",
	3:  "amount_min",
	4:  "amount_max",
	5:  "date",
	6:  "end_date",
	7:  "extension_date",
	8:  "repeat_freq",
	9:  "skip",
	10: "active",
	11: "notes",
	12: "object_group_id",
	13: "object_group_title",
}

// Decode decodes BillUpdate from json.
func (s *BillUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BillUpdate to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "amount_min":
			if err := func() error {
				s.AmountMin.Reset()
				if err := s.AmountMin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount_min\"")
			}
		case "amount_max":
			if err := func() error {
				s.AmountMax.Reset()
				if err := s.AmountMax.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount_max\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "end_date":
			if err := func() error {
				s.EndDate.Reset()
				if err := s.EndDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_date\"")
			}
		case "extension_date":
			if err := func() error {
				s.ExtensionDate.Reset()
				if err := s.ExtensionDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extension_date\"")
			}
		case "repeat_freq":
			if err := func() error {
				s.RepeatFreq.Reset()
				if err := s.RepeatFreq.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repeat_freq\"")
			}
		case "skip":
			if err := func() error {
				s.Skip.Reset()
				if err := s.Skip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skip\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "object_group_id":
			if err := func() error {
				s.ObjectGroupID.Reset()
				if err := s.ObjectGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_id\"")
			}
		case "object_group_title":
			if err := func() error {
				s.ObjectGroupTitle.Reset()
				if err := s.ObjectGroupTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BillUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBillUpdate) {
					name = jsonFieldsNameOfBillUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BillUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BillUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Budget) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Budget) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.AutoBudgetType.Set {
			e.FieldStart("auto_budget_type")
			s.AutoBudgetType.Encode(e)
		}
	}
	{
		if s.AutoBudgetCurrencyID.Set {
			e.FieldStart("auto_budget_currency_id")
			s.AutoBudgetCurrencyID.Encode(e)
		}
	}
	{
		if s.AutoBudgetCurrencyCode.Set {
			e.FieldStart("auto_budget_currency_code")
			s.AutoBudgetCurrencyCode.Encode(e)
		}
	}
	{
		if s.AutoBudgetAmount.Set {
			e.FieldStart("auto_budget_amount")
			s.AutoBudgetAmount.Encode(e)
		}
	}
	{
		if s.AutoBudgetPeriod.Set {
			e.FieldStart("auto_budget_period")
			s.AutoBudgetPeriod.Encode(e)
		}
	}
	{
		if s.Spent != nil {
			e.FieldStart("spent")
			e.ArrStart()
			for _, elem := range s.Spent {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBudget = [12]string{
	0:  "created_at",
	1:  "updated_at",
	2:  "name",
	3:  "active",
	4:  "notes",
	5:  "order",
	6:  "auto_budget_type",
	7:  "auto_budget_currency_id",
	8:  "auto_budget_currency_code",
	9:  "auto_budget_amount",
	10: "auto_budget_period",
	11: "spent",
}

// Decode decodes Budget from json.
func (s *Budget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Budget to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "auto_budget_type":
			if err := func() error {
				s.AutoBudgetType.Reset()
				if err := s.AutoBudgetType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_budget_type\"")
			}
		case "auto_budget_currency_id":
			if err := func() error {
				s.AutoBudgetCurrencyID.Reset()
				if err := s.AutoBudgetCurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_budget_currency_id\"")
			}
		case "auto_budget_currency_code":
			if err := func() error {
				s.AutoBudgetCurrencyCode.Reset()
				if err := s.AutoBudgetCurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_budget_currency_code\"")
			}
		case "auto_budget_amount":
			if err := func() error {
				s.AutoBudgetAmount.Reset()
				if err := s.AutoBudgetAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_budget_amount\"")
			}
		case "auto_budget_period":
			if err := func() error {
				s.AutoBudgetPeriod.Reset()
				if err := s.AutoBudgetPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_budget_period\"")
			}
		case "spent":
			if err := func() error {
				s.Spent = make([]BudgetSpent, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BudgetSpent
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Spent = append(s.Spent, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Budget")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBudget) {
					name = jsonFieldsNameOfBudget[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Budget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Budget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BudgetArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BudgetArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
}

var jsonFieldsNameOfBudgetArray = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes BudgetArray from json.
func (s *BudgetArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BudgetArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]BudgetRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BudgetRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BudgetArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBudgetArray) {
					name = jsonFieldsNameOfBudgetArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BudgetArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BudgetArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BudgetLimit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BudgetLimit) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("start")
		json.EncodeDateTime(e, s.Start)
	}
	{
		e.FieldStart("end")
		json.EncodeDateTime(e, s.End)
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.CurrencyName.Set {
			e.FieldStart("currency_name")
			s.CurrencyName.Encode(e)
		}
	}
	{
		if s.CurrencySymbol.Set {
			e.FieldStart("currency_symbol")
			s.CurrencySymbol.Encode(e)
		}
	}
	{
		if s.CurrencyDecimalPlaces.Set {
			e.FieldStart("currency_decimal_places")
			s.CurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		e.FieldStart("budget_id")
		e.Str(s.BudgetID)
	}
	{
		if s.Period.Set {
			e.FieldStart("period")
			s.Period.Encode(e)
		}
	}
	{
		e.FieldStart("amount")
		e.Str(s.Amount)
	}
	{
		if s.Spent.Set {
			e.FieldStart("spent")
			s.Spent.Encode(e)
		}
	}
}

var jsonFieldsNameOfBudgetLimit = [13]string{
	0:  "created_at",
	1:  "updated_at",
	2:  "start",
	3:  "end",
	4:  "currency_id",
	5:  "currency_code",
	6:  "currency_name",
	7:  "currency_symbol",
	8:  "currency_decimal_places",
	9:  "budget_id",
	10: "period",
	11: "amount",
	12: "spent",
}

// Decode decodes BudgetLimit from json.
func (s *BudgetLimit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BudgetLimit to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "start":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Start = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.End = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "currency_name":
			if err := func() error {
				s.CurrencyName.Reset()
				if err := s.CurrencyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_name\"")
			}
		case "currency_symbol":
			if err := func() error {
				s.CurrencySymbol.Reset()
				if err := s.CurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_symbol\"")
			}
		case "currency_decimal_places":
			if err := func() error {
				s.CurrencyDecimalPlaces.Reset()
				if err := s.CurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_decimal_places\"")
			}
		case "budget_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BudgetID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"budget_id\"")
			}
		case "period":
			if err := func() error {
				s.Period.Reset()
				if err := s.Period.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"period\"")
			}
		case "amount":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Amount = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "spent":
			if err := func() error {
				s.Spent.Reset()
				if err := s.Spent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BudgetLimit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001100,
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBudgetLimit) {
					name = jsonFieldsNameOfBudgetLimit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BudgetLimit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BudgetLimit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BudgetLimitArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BudgetLimitArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
}

var jsonFieldsNameOfBudgetLimitArray = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes BudgetLimitArray from json.
func (s *BudgetLimitArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BudgetLimitArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]BudgetLimitRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BudgetLimitRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BudgetLimitArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBudgetLimitArray) {
					name = jsonFieldsNameOfBudgetLimitArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BudgetLimitArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BudgetLimitArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BudgetLimitRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BudgetLimitRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
}

var jsonFieldsNameOfBudgetLimitRead = [3]string{
	0: "type",
	1: "id",
	2: "attributes",
}

// Decode decodes BudgetLimitRead from json.
func (s *BudgetLimitRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BudgetLimitRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BudgetLimitRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBudgetLimitRead) {
					name = jsonFieldsNameOfBudgetLimitRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BudgetLimitRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BudgetLimitRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BudgetLimitSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BudgetLimitSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfBudgetLimitSingle = [1]string{
	0: "data",
}

// Decode decodes BudgetLimitSingle from json.
func (s *BudgetLimitSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BudgetLimitSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BudgetLimitSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBudgetLimitSingle) {
					name = jsonFieldsNameOfBudgetLimitSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BudgetLimitSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BudgetLimitSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BudgetLimitStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BudgetLimitStore) encodeFields(e *jx.Encoder) {
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		e.FieldStart("budget_id")
		e.Str(s.BudgetID)
	}
	{
		e.FieldStart("start")
		json.EncodeDate(e, s.Start)
	}
	{
		if s.Period.Set {
			e.FieldStart("period")
			s.Period.Encode(e)
		}
	}
	{
		e.FieldStart("end")
		json.EncodeDate(e, s.End)
	}
	{
		e.FieldStart("amount")
		e.Str(s.Amount)
	}
}

var jsonFieldsNameOfBudgetLimitStore = [7]string{
	0: "currency_id",
	1: "currency_code",
	2: "budget_id",
	3: "start",
	4: "period",
	5: "end",
	6: "amount",
}

// Decode decodes BudgetLimitStore from json.
func (s *BudgetLimitStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BudgetLimitStore to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "budget_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BudgetID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"budget_id\"")
			}
		case "start":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.Start = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "period":
			if err := func() error {
				s.Period.Reset()
				if err := s.Period.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"period\"")
			}
		case "end":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.End = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Amount = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BudgetLimitStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01101100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBudgetLimitStore) {
					name = jsonFieldsNameOfBudgetLimitStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BudgetLimitStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BudgetLimitStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BudgetRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BudgetRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
}

var jsonFieldsNameOfBudgetRead = [3]string{
	0: "type",
	1: "id",
	2: "attributes",
}

// Decode decodes BudgetRead from json.
func (s *BudgetRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BudgetRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BudgetRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBudgetRead) {
					name = jsonFieldsNameOfBudgetRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BudgetRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BudgetRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BudgetSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BudgetSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfBudgetSingle = [1]string{
	0: "data",
}

// Decode decodes BudgetSingle from json.
func (s *BudgetSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BudgetSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BudgetSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBudgetSingle) {
					name = jsonFieldsNameOfBudgetSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BudgetSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BudgetSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BudgetSpent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BudgetSpent) encodeFields(e *jx.Encoder) {
	{
		if s.Sum.Set {
			e.FieldStart("sum")
			s.Sum.Encode(e)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.CurrencySymbol.Set {
			e.FieldStart("currency_symbol")
			s.CurrencySymbol.Encode(e)
		}
	}
	{
		if s.CurrencyDecimalPlaces.Set {
			e.FieldStart("currency_decimal_places")
			s.CurrencyDecimalPlaces.Encode(e)
		}
	}
}

var jsonFieldsNameOfBudgetSpent = [5]string{
	0: "sum",
	1: "currency_id",
	2: "currency_code",
	3: "currency_symbol",
	4: "currency_decimal_places",
}

// Decode decodes BudgetSpent from json.
func (s *BudgetSpent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BudgetSpent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sum":
			if err := func() error {
				s.Sum.Reset()
				if err := s.Sum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sum\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "currency_symbol":
			if err := func() error {
				s.CurrencySymbol.Reset()
				if err := s.CurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_symbol\"")
			}
		case "currency_decimal_places":
			if err := func() error {
				s.CurrencyDecimalPlaces.Reset()
				if err := s.CurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_decimal_places\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BudgetSpent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BudgetSpent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BudgetSpent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BudgetStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BudgetStore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.AutoBudgetType.Set {
			e.FieldStart("auto_budget_type")
			s.AutoBudgetType.Encode(e)
		}
	}
	{
		if s.AutoBudgetCurrencyID.Set {
			e.FieldStart("auto_budget_currency_id")
			s.AutoBudgetCurrencyID.Encode(e)
		}
	}
	{
		if s.AutoBudgetCurrencyCode.Set {
			e.FieldStart("auto_budget_currency_code")
			s.AutoBudgetCurrencyCode.Encode(e)
		}
	}
	{
		if s.AutoBudgetAmount.Set {
			e.FieldStart("auto_budget_amount")
			s.AutoBudgetAmount.Encode(e)
		}
	}
	{
		if s.AutoBudgetPeriod.Set {
			e.FieldStart("auto_budget_period")
			s.AutoBudgetPeriod.Encode(e)
		}
	}
}

var jsonFieldsNameOfBudgetStore = [9]string{
	0: "name",
	1: "active",
	2: "order",
	3: "notes",
	4: "auto_budget_type",
	5: "auto_budget_currency_id",
	6: "auto_budget_currency_code",
	7: "auto_budget_amount",
	8: "auto_budget_period",
}

// Decode decodes BudgetStore from json.
func (s *BudgetStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BudgetStore to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "auto_budget_type":
			if err := func() error {
				s.AutoBudgetType.Reset()
				if err := s.AutoBudgetType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_budget_type\"")
			}
		case "auto_budget_currency_id":
			if err := func() error {
				s.AutoBudgetCurrencyID.Reset()
				if err := s.AutoBudgetCurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_budget_currency_id\"")
			}
		case "auto_budget_currency_code":
			if err := func() error {
				s.AutoBudgetCurrencyCode.Reset()
				if err := s.AutoBudgetCurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_budget_currency_code\"")
			}
		case "auto_budget_amount":
			if err := func() error {
				s.AutoBudgetAmount.Reset()
				if err := s.AutoBudgetAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_budget_amount\"")
			}
		case "auto_budget_period":
			if err := func() error {
				s.AutoBudgetPeriod.Reset()
				if err := s.AutoBudgetPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_budget_period\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BudgetStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBudgetStore) {
					name = jsonFieldsNameOfBudgetStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BudgetStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BudgetStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BudgetUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BudgetUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.AutoBudgetType.Set {
			e.FieldStart("auto_budget_type")
			s.AutoBudgetType.Encode(e)
		}
	}
	{
		if s.AutoBudgetCurrencyID.Set {
			e.FieldStart("auto_budget_currency_id")
			s.AutoBudgetCurrencyID.Encode(e)
		}
	}
	{
		if s.AutoBudgetCurrencyCode.Set {
			e.FieldStart("auto_budget_currency_code")
			s.AutoBudgetCurrencyCode.Encode(e)
		}
	}
	{
		if s.AutoBudgetAmount.Set {
			e.FieldStart("auto_budget_amount")
			s.AutoBudgetAmount.Encode(e)
		}
	}
	{
		if s.AutoBudgetPeriod.Set {
			e.FieldStart("auto_budget_period")
			s.AutoBudgetPeriod.Encode(e)
		}
	}
}

var jsonFieldsNameOfBudgetUpdate = [9]string{
	0: "name",
	1: "active",
	2: "order",
	3: "notes",
	4: "auto_budget_type",
	5: "auto_budget_currency_id",
	6: "auto_budget_currency_code",
	7: "auto_budget_amount",
	8: "auto_budget_period",
}

// Decode decodes BudgetUpdate from json.
func (s *BudgetUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BudgetUpdate to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "auto_budget_type":
			if err := func() error {
				s.AutoBudgetType.Reset()
				if err := s.AutoBudgetType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_budget_type\"")
			}
		case "auto_budget_currency_id":
			if err := func() error {
				s.AutoBudgetCurrencyID.Reset()
				if err := s.AutoBudgetCurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_budget_currency_id\"")
			}
		case "auto_budget_currency_code":
			if err := func() error {
				s.AutoBudgetCurrencyCode.Reset()
				if err := s.AutoBudgetCurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_budget_currency_code\"")
			}
		case "auto_budget_amount":
			if err := func() error {
				s.AutoBudgetAmount.Reset()
				if err := s.AutoBudgetAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_budget_amount\"")
			}
		case "auto_budget_period":
			if err := func() error {
				s.AutoBudgetPeriod.Reset()
				if err := s.AutoBudgetPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_budget_period\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BudgetUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBudgetUpdate) {
					name = jsonFieldsNameOfBudgetUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BudgetUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BudgetUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Category) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Category) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.Spent != nil {
			e.FieldStart("spent")
			e.ArrStart()
			for _, elem := range s.Spent {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Earned != nil {
			e.FieldStart("earned")
			e.ArrStart()
			for _, elem := range s.Earned {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCategory = [6]string{
	0: "created_at",
	1: "updated_at",
	2: "name",
	3: "notes",
	4: "spent",
	5: "earned",
}

// Decode decodes Category from json.
func (s *Category) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Category to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "spent":
			if err := func() error {
				s.Spent = make([]CategorySpent, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CategorySpent
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Spent = append(s.Spent, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spent\"")
			}
		case "earned":
			if err := func() error {
				s.Earned = make([]CategoryEarned, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CategoryEarned
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Earned = append(s.Earned, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"earned\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Category")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategory) {
					name = jsonFieldsNameOfCategory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Category) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Category) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoryArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoryArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
}

var jsonFieldsNameOfCategoryArray = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes CategoryArray from json.
func (s *CategoryArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]CategoryRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CategoryRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryArray) {
					name = jsonFieldsNameOfCategoryArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoryArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoryArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoryEarned) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoryEarned) encodeFields(e *jx.Encoder) {
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.CurrencySymbol.Set {
			e.FieldStart("currency_symbol")
			s.CurrencySymbol.Encode(e)
		}
	}
	{
		if s.CurrencyDecimalPlaces.Set {
			e.FieldStart("currency_decimal_places")
			s.CurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		if s.Sum.Set {
			e.FieldStart("sum")
			s.Sum.Encode(e)
		}
	}
}

var jsonFieldsNameOfCategoryEarned = [5]string{
	0: "currency_id",
	1: "currency_code",
	2: "currency_symbol",
	3: "currency_decimal_places",
	4: "sum",
}

// Decode decodes CategoryEarned from json.
func (s *CategoryEarned) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryEarned to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "currency_symbol":
			if err := func() error {
				s.CurrencySymbol.Reset()
				if err := s.CurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_symbol\"")
			}
		case "currency_decimal_places":
			if err := func() error {
				s.CurrencyDecimalPlaces.Reset()
				if err := s.CurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_decimal_places\"")
			}
		case "sum":
			if err := func() error {
				s.Sum.Reset()
				if err := s.Sum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sum\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryEarned")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoryEarned) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoryEarned) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoryRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoryRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
}

var jsonFieldsNameOfCategoryRead = [3]string{
	0: "type",
	1: "id",
	2: "attributes",
}

// Decode decodes CategoryRead from json.
func (s *CategoryRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryRead) {
					name = jsonFieldsNameOfCategoryRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoryRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoryRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategorySingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategorySingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCategorySingle = [1]string{
	0: "data",
}

// Decode decodes CategorySingle from json.
func (s *CategorySingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategorySingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategorySingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategorySingle) {
					name = jsonFieldsNameOfCategorySingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategorySingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategorySingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategorySpent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategorySpent) encodeFields(e *jx.Encoder) {
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.CurrencySymbol.Set {
			e.FieldStart("currency_symbol")
			s.CurrencySymbol.Encode(e)
		}
	}
	{
		if s.CurrencyDecimalPlaces.Set {
			e.FieldStart("currency_decimal_places")
			s.CurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		if s.Sum.Set {
			e.FieldStart("sum")
			s.Sum.Encode(e)
		}
	}
}

var jsonFieldsNameOfCategorySpent = [5]string{
	0: "currency_id",
	1: "currency_code",
	2: "currency_symbol",
	3: "currency_decimal_places",
	4: "sum",
}

// Decode decodes CategorySpent from json.
func (s *CategorySpent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategorySpent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "currency_symbol":
			if err := func() error {
				s.CurrencySymbol.Reset()
				if err := s.CurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_symbol\"")
			}
		case "currency_decimal_places":
			if err := func() error {
				s.CurrencyDecimalPlaces.Reset()
				if err := s.CurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_decimal_places\"")
			}
		case "sum":
			if err := func() error {
				s.Sum.Reset()
				if err := s.Sum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sum\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategorySpent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategorySpent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategorySpent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoryUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoryUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
}

var jsonFieldsNameOfCategoryUpdate = [2]string{
	0: "name",
	1: "notes",
}

// Decode decodes CategoryUpdate from json.
func (s *CategoryUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryUpdate) {
					name = jsonFieldsNameOfCategoryUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoryUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoryUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChartDataPoint) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChartDataPoint) encodeFields(e *jx.Encoder) {
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
}

var jsonFieldsNameOfChartDataPoint = [1]string{
	0: "key",
}

// Decode decodes ChartDataPoint from json.
func (s *ChartDataPoint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChartDataPoint to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChartDataPoint")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChartDataPoint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChartDataPoint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChartDataSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChartDataSet) encodeFields(e *jx.Encoder) {
	{
		if s.Label.Set {
			e.FieldStart("label")
			s.Label.Encode(e)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.CurrencySymbol.Set {
			e.FieldStart("currency_symbol")
			s.CurrencySymbol.Encode(e)
		}
	}
	{
		if s.CurrencyDecimalPlaces.Set {
			e.FieldStart("currency_decimal_places")
			s.CurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		if s.StartDate.Set {
			e.FieldStart("start_date")
			s.StartDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EndDate.Set {
			e.FieldStart("end_date")
			s.EndDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.YAxisID.Set {
			e.FieldStart("yAxisID")
			s.YAxisID.Encode(e)
		}
	}
	{
		if s.Entries.Set {
			e.FieldStart("entries")
			s.Entries.Encode(e)
		}
	}
}

var jsonFieldsNameOfChartDataSet = [10]string{
	0: "label",
	1: "currency_id",
	2: "currency_code",
	3: "currency_symbol",
	4: "currency_decimal_places",
	5: "start_date",
	6: "end_date",
	7: "type",
	8: "yAxisID",
	9: "entries",
}

// Decode decodes ChartDataSet from json.
func (s *ChartDataSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChartDataSet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			if err := func() error {
				s.Label.Reset()
				if err := s.Label.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "currency_symbol":
			if err := func() error {
				s.CurrencySymbol.Reset()
				if err := s.CurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_symbol\"")
			}
		case "currency_decimal_places":
			if err := func() error {
				s.CurrencyDecimalPlaces.Reset()
				if err := s.CurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_decimal_places\"")
			}
		case "start_date":
			if err := func() error {
				s.StartDate.Reset()
				if err := s.StartDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_date\"")
			}
		case "end_date":
			if err := func() error {
				s.EndDate.Reset()
				if err := s.EndDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_date\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "yAxisID":
			if err := func() error {
				s.YAxisID.Reset()
				if err := s.YAxisID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"yAxisID\"")
			}
		case "entries":
			if err := func() error {
				s.Entries.Reset()
				if err := s.Entries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entries\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChartDataSet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChartDataSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChartDataSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ChartDataSetEntries) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ChartDataSetEntries) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes ChartDataSetEntries from json.
func (s *ChartDataSetEntries) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChartDataSetEntries to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem ChartDataPoint
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChartDataSetEntries")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChartDataSetEntries) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChartDataSetEntries) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChartLine as json.
func (s ChartLine) Encode(e *jx.Encoder) {
	unwrapped := []ChartDataSet(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ChartLine from json.
func (s *ChartLine) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChartLine to nil")
	}
	var unwrapped []ChartDataSet
	if err := func() error {
		unwrapped = make([]ChartDataSet, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ChartDataSet
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ChartLine(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChartLine) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChartLine) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigValueFilter as json.
func (s ConfigValueFilter) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConfigValueFilter from json.
func (s *ConfigValueFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigValueFilter to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConfigValueFilter(v) {
	case ConfigValueFilterConfigurationIsDemoSite:
		*s = ConfigValueFilterConfigurationIsDemoSite
	case ConfigValueFilterConfigurationPermissionUpdateCheck:
		*s = ConfigValueFilterConfigurationPermissionUpdateCheck
	case ConfigValueFilterConfigurationLastUpdateCheck:
		*s = ConfigValueFilterConfigurationLastUpdateCheck
	case ConfigValueFilterConfigurationSingleUserMode:
		*s = ConfigValueFilterConfigurationSingleUserMode
	case ConfigValueFilterFireflyVersion:
		*s = ConfigValueFilterFireflyVersion
	case ConfigValueFilterFireflyAPIVersion:
		*s = ConfigValueFilterFireflyAPIVersion
	case ConfigValueFilterFireflyDefaultLocation:
		*s = ConfigValueFilterFireflyDefaultLocation
	case ConfigValueFilterFireflyAccountToTransaction:
		*s = ConfigValueFilterFireflyAccountToTransaction
	case ConfigValueFilterFireflyAllowedOpposingTypes:
		*s = ConfigValueFilterFireflyAllowedOpposingTypes
	case ConfigValueFilterFireflyAccountRoles:
		*s = ConfigValueFilterFireflyAccountRoles
	case ConfigValueFilterFireflyValidLiabilities:
		*s = ConfigValueFilterFireflyValidLiabilities
	case ConfigValueFilterFireflyInterestPeriods:
		*s = ConfigValueFilterFireflyInterestPeriods
	case ConfigValueFilterFireflyEnableExternalMap:
		*s = ConfigValueFilterFireflyEnableExternalMap
	case ConfigValueFilterFireflyExpectedSourceTypes:
		*s = ConfigValueFilterFireflyExpectedSourceTypes
	case ConfigValueFilterAppTimezone:
		*s = ConfigValueFilterAppTimezone
	case ConfigValueFilterFireflyBillPeriods:
		*s = ConfigValueFilterFireflyBillPeriods
	case ConfigValueFilterFireflyCreditCardTypes:
		*s = ConfigValueFilterFireflyCreditCardTypes
	case ConfigValueFilterFireflyLanguages:
		*s = ConfigValueFilterFireflyLanguages
	case ConfigValueFilterFireflyValidViewRanges:
		*s = ConfigValueFilterFireflyValidViewRanges
	default:
		*s = ConfigValueFilter(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConfigValueFilter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigValueFilter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Configuration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Configuration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		s.Title.Encode(e)
	}
	{
		e.FieldStart("value")
		s.Value.Encode(e)
	}
	{
		e.FieldStart("editable")
		e.Bool(s.Editable)
	}
}

var jsonFieldsNameOfConfiguration = [3]string{
	0: "title",
	1: "value",
	2: "editable",
}

// Decode decodes Configuration from json.
func (s *Configuration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Configuration to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "editable":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Editable = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"editable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Configuration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfiguration) {
					name = jsonFieldsNameOfConfiguration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Configuration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Configuration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigurationArray as json.
func (s ConfigurationArray) Encode(e *jx.Encoder) {
	unwrapped := []Configuration(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ConfigurationArray from json.
func (s *ConfigurationArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigurationArray to nil")
	}
	var unwrapped []Configuration
	if err := func() error {
		unwrapped = make([]Configuration, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Configuration
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ConfigurationArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConfigurationArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigurationArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigurationSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigurationSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfConfigurationSingle = [1]string{
	0: "data",
}

// Decode decodes ConfigurationSingle from json.
func (s *ConfigurationSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigurationSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigurationSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfigurationSingle) {
					name = jsonFieldsNameOfConfigurationSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigurationSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigurationSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigurationUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigurationUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("value")
		s.Value.Encode(e)
	}
}

var jsonFieldsNameOfConfigurationUpdate = [1]string{
	0: "value",
}

// Decode decodes ConfigurationUpdate from json.
func (s *ConfigurationUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigurationUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigurationUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfigurationUpdate) {
					name = jsonFieldsNameOfConfigurationUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigurationUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigurationUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreditCardType as json.
func (s CreditCardType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreditCardType from json.
func (s *CreditCardType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreditCardType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreditCardType(v) {
	case CreditCardTypeMonthlyFull:
		*s = CreditCardTypeMonthlyFull
	default:
		*s = CreditCardType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreditCardType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreditCardType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CronResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CronResult) encodeFields(e *jx.Encoder) {
	{
		if s.RecurringTransactions.Set {
			e.FieldStart("recurring_transactions")
			s.RecurringTransactions.Encode(e)
		}
	}
	{
		if s.AutoBudgets.Set {
			e.FieldStart("auto_budgets")
			s.AutoBudgets.Encode(e)
		}
	}
	{
		if s.Telemetry.Set {
			e.FieldStart("telemetry")
			s.Telemetry.Encode(e)
		}
	}
}

var jsonFieldsNameOfCronResult = [3]string{
	0: "recurring_transactions",
	1: "auto_budgets",
	2: "telemetry",
}

// Decode decodes CronResult from json.
func (s *CronResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CronResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "recurring_transactions":
			if err := func() error {
				s.RecurringTransactions.Reset()
				if err := s.RecurringTransactions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recurring_transactions\"")
			}
		case "auto_budgets":
			if err := func() error {
				s.AutoBudgets.Reset()
				if err := s.AutoBudgets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_budgets\"")
			}
		case "telemetry":
			if err := func() error {
				s.Telemetry.Reset()
				if err := s.Telemetry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telemetry\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CronResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CronResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CronResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CronResultRow) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CronResultRow) encodeFields(e *jx.Encoder) {
	{
		if s.JobFired.Set {
			e.FieldStart("job_fired")
			s.JobFired.Encode(e)
		}
	}
	{
		if s.JobSucceeded.Set {
			e.FieldStart("job_succeeded")
			s.JobSucceeded.Encode(e)
		}
	}
	{
		if s.JobErrored.Set {
			e.FieldStart("job_errored")
			s.JobErrored.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfCronResultRow = [4]string{
	0: "job_fired",
	1: "job_succeeded",
	2: "job_errored",
	3: "message",
}

// Decode decodes CronResultRow from json.
func (s *CronResultRow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CronResultRow to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "job_fired":
			if err := func() error {
				s.JobFired.Reset()
				if err := s.JobFired.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"job_fired\"")
			}
		case "job_succeeded":
			if err := func() error {
				s.JobSucceeded.Reset()
				if err := s.JobSucceeded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"job_succeeded\"")
			}
		case "job_errored":
			if err := func() error {
				s.JobErrored.Reset()
				if err := s.JobErrored.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"job_errored\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CronResultRow")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CronResultRow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CronResultRow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Currency) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Currency) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.Default.Set {
			e.FieldStart("default")
			s.Default.Encode(e)
		}
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("symbol")
		e.Str(s.Symbol)
	}
	{
		if s.DecimalPlaces.Set {
			e.FieldStart("decimal_places")
			s.DecimalPlaces.Encode(e)
		}
	}
}

var jsonFieldsNameOfCurrency = [8]string{
	0: "created_at",
	1: "updated_at",
	2: "enabled",
	3: "default",
	4: "code",
	5: "name",
	6: "symbol",
	7: "decimal_places",
}

// Decode decodes Currency from json.
func (s *Currency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Currency to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "default":
			if err := func() error {
				s.Default.Reset()
				if err := s.Default.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "symbol":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Symbol = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbol\"")
			}
		case "decimal_places":
			if err := func() error {
				s.DecimalPlaces.Reset()
				if err := s.DecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decimal_places\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Currency")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCurrency) {
					name = jsonFieldsNameOfCurrency[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Currency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Currency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CurrencyArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CurrencyArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfCurrencyArray = [3]string{
	0: "data",
	1: "meta",
	2: "links",
}

// Decode decodes CurrencyArray from json.
func (s *CurrencyArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CurrencyArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]CurrencyRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CurrencyRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CurrencyArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCurrencyArray) {
					name = jsonFieldsNameOfCurrencyArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CurrencyArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CurrencyArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CurrencyRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CurrencyRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
}

var jsonFieldsNameOfCurrencyRead = [3]string{
	0: "type",
	1: "id",
	2: "attributes",
}

// Decode decodes CurrencyRead from json.
func (s *CurrencyRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CurrencyRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CurrencyRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCurrencyRead) {
					name = jsonFieldsNameOfCurrencyRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CurrencyRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CurrencyRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CurrencySingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CurrencySingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfCurrencySingle = [1]string{
	0: "data",
}

// Decode decodes CurrencySingle from json.
func (s *CurrencySingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CurrencySingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CurrencySingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCurrencySingle) {
					name = jsonFieldsNameOfCurrencySingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CurrencySingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CurrencySingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CurrencyStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CurrencyStore) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.Default.Set {
			e.FieldStart("default")
			s.Default.Encode(e)
		}
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("symbol")
		e.Str(s.Symbol)
	}
	{
		if s.DecimalPlaces.Set {
			e.FieldStart("decimal_places")
			s.DecimalPlaces.Encode(e)
		}
	}
}

var jsonFieldsNameOfCurrencyStore = [6]string{
	0: "enabled",
	1: "default",
	2: "code",
	3: "name",
	4: "symbol",
	5: "decimal_places",
}

// Decode decodes CurrencyStore from json.
func (s *CurrencyStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CurrencyStore to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "default":
			if err := func() error {
				s.Default.Reset()
				if err := s.Default.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "symbol":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Symbol = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbol\"")
			}
		case "decimal_places":
			if err := func() error {
				s.DecimalPlaces.Reset()
				if err := s.DecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decimal_places\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CurrencyStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCurrencyStore) {
					name = jsonFieldsNameOfCurrencyStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CurrencyStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CurrencyStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CurrencyUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CurrencyUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.Default.Set {
			e.FieldStart("default")
			s.Default.Encode(e)
		}
	}
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Symbol.Set {
			e.FieldStart("symbol")
			s.Symbol.Encode(e)
		}
	}
	{
		if s.DecimalPlaces.Set {
			e.FieldStart("decimal_places")
			s.DecimalPlaces.Encode(e)
		}
	}
}

var jsonFieldsNameOfCurrencyUpdate = [6]string{
	0: "enabled",
	1: "default",
	2: "code",
	3: "name",
	4: "symbol",
	5: "decimal_places",
}

// Decode decodes CurrencyUpdate from json.
func (s *CurrencyUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CurrencyUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "default":
			if err := func() error {
				s.Default.Reset()
				if err := s.Default.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "symbol":
			if err := func() error {
				s.Symbol.Reset()
				if err := s.Symbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbol\"")
			}
		case "decimal_places":
			if err := func() error {
				s.DecimalPlaces.Reset()
				if err := s.DecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decimal_places\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CurrencyUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CurrencyUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CurrencyUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CurrencyUpdateDefault as json.
func (s CurrencyUpdateDefault) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes CurrencyUpdateDefault from json.
func (s *CurrencyUpdateDefault) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CurrencyUpdateDefault to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = CurrencyUpdateDefault(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CurrencyUpdateDefault) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CurrencyUpdateDefault) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InsightGroup as json.
func (s InsightGroup) Encode(e *jx.Encoder) {
	unwrapped := []InsightGroupEntry(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes InsightGroup from json.
func (s *InsightGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InsightGroup to nil")
	}
	var unwrapped []InsightGroupEntry
	if err := func() error {
		unwrapped = make([]InsightGroupEntry, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem InsightGroupEntry
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = InsightGroup(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InsightGroup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InsightGroup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InsightGroupEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InsightGroupEntry) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Difference.Set {
			e.FieldStart("difference")
			s.Difference.Encode(e)
		}
	}
	{
		if s.DifferenceFloat.Set {
			e.FieldStart("difference_float")
			s.DifferenceFloat.Encode(e)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInsightGroupEntry = [6]string{
	0: "id",
	1: "name",
	2: "difference",
	3: "difference_float",
	4: "currency_id",
	5: "currency_code",
}

// Decode decodes InsightGroupEntry from json.
func (s *InsightGroupEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InsightGroupEntry to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "difference":
			if err := func() error {
				s.Difference.Reset()
				if err := s.Difference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		case "difference_float":
			if err := func() error {
				s.DifferenceFloat.Reset()
				if err := s.DifferenceFloat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference_float\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InsightGroupEntry")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InsightGroupEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InsightGroupEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InsightTotal as json.
func (s InsightTotal) Encode(e *jx.Encoder) {
	unwrapped := []InsightTotalEntry(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes InsightTotal from json.
func (s *InsightTotal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InsightTotal to nil")
	}
	var unwrapped []InsightTotalEntry
	if err := func() error {
		unwrapped = make([]InsightTotalEntry, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem InsightTotalEntry
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = InsightTotal(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InsightTotal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InsightTotal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InsightTotalEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InsightTotalEntry) encodeFields(e *jx.Encoder) {
	{
		if s.Difference.Set {
			e.FieldStart("difference")
			s.Difference.Encode(e)
		}
	}
	{
		if s.DifferenceFloat.Set {
			e.FieldStart("difference_float")
			s.DifferenceFloat.Encode(e)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInsightTotalEntry = [4]string{
	0: "difference",
	1: "difference_float",
	2: "currency_id",
	3: "currency_code",
}

// Decode decodes InsightTotalEntry from json.
func (s *InsightTotalEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InsightTotalEntry to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "difference":
			if err := func() error {
				s.Difference.Reset()
				if err := s.Difference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		case "difference_float":
			if err := func() error {
				s.DifferenceFloat.Reset()
				if err := s.DifferenceFloat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference_float\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InsightTotalEntry")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InsightTotalEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InsightTotalEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InsightTransfer as json.
func (s InsightTransfer) Encode(e *jx.Encoder) {
	unwrapped := []InsightTransferEntry(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes InsightTransfer from json.
func (s *InsightTransfer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InsightTransfer to nil")
	}
	var unwrapped []InsightTransferEntry
	if err := func() error {
		unwrapped = make([]InsightTransferEntry, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem InsightTransferEntry
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = InsightTransfer(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InsightTransfer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InsightTransfer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InsightTransferEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InsightTransferEntry) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Difference.Set {
			e.FieldStart("difference")
			s.Difference.Encode(e)
		}
	}
	{
		if s.DifferenceFloat.Set {
			e.FieldStart("difference_float")
			s.DifferenceFloat.Encode(e)
		}
	}
	{
		if s.In.Set {
			e.FieldStart("in")
			s.In.Encode(e)
		}
	}
	{
		if s.InFloat.Set {
			e.FieldStart("in_float")
			s.InFloat.Encode(e)
		}
	}
	{
		if s.Out.Set {
			e.FieldStart("out")
			s.Out.Encode(e)
		}
	}
	{
		if s.OutFloat.Set {
			e.FieldStart("out_float")
			s.OutFloat.Encode(e)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInsightTransferEntry = [10]string{
	0: "id",
	1: "name",
	2: "difference",
	3: "difference_float",
	4: "in",
	5: "in_float",
	6: "out",
	7: "out_float",
	8: "currency_id",
	9: "currency_code",
}

// Decode decodes InsightTransferEntry from json.
func (s *InsightTransferEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InsightTransferEntry to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "difference":
			if err := func() error {
				s.Difference.Reset()
				if err := s.Difference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		case "difference_float":
			if err := func() error {
				s.DifferenceFloat.Reset()
				if err := s.DifferenceFloat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference_float\"")
			}
		case "in":
			if err := func() error {
				s.In.Reset()
				if err := s.In.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"in\"")
			}
		case "in_float":
			if err := func() error {
				s.InFloat.Reset()
				if err := s.InFloat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"in_float\"")
			}
		case "out":
			if err := func() error {
				s.Out.Reset()
				if err := s.Out.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"out\"")
			}
		case "out_float":
			if err := func() error {
				s.OutFloat.Reset()
				if err := s.OutFloat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"out_float\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InsightTransferEntry")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InsightTransferEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InsightTransferEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InterestPeriod as json.
func (s InterestPeriod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InterestPeriod from json.
func (s *InterestPeriod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InterestPeriod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InterestPeriod(v) {
	case InterestPeriodWeekly:
		*s = InterestPeriodWeekly
	case InterestPeriodMonthly:
		*s = InterestPeriodMonthly
	case InterestPeriodQuarterly:
		*s = InterestPeriodQuarterly
	case InterestPeriodHalfYear:
		*s = InterestPeriodHalfYear
	case InterestPeriodYearly:
		*s = InterestPeriodYearly
	default:
		*s = InterestPeriod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InterestPeriod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InterestPeriod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalException) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalException) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Exception.Set {
			e.FieldStart("exception")
			s.Exception.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalException = [2]string{
	0: "message",
	1: "exception",
}

// Decode decodes InternalException from json.
func (s *InternalException) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalException to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "exception":
			if err := func() error {
				s.Exception.Reset()
				if err := s.Exception.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exception\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalException")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalException) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalException) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LiabilityDirection as json.
func (s LiabilityDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LiabilityDirection from json.
func (s *LiabilityDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LiabilityDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LiabilityDirection(v) {
	case LiabilityDirectionCredit:
		*s = LiabilityDirectionCredit
	case LiabilityDirectionDebit:
		*s = LiabilityDirectionDebit
	default:
		*s = LiabilityDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LiabilityDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LiabilityDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LiabilityType as json.
func (s LiabilityType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LiabilityType from json.
func (s *LiabilityType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LiabilityType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LiabilityType(v) {
	case LiabilityTypeLoan:
		*s = LiabilityTypeLoan
	case LiabilityTypeDebt:
		*s = LiabilityTypeDebt
	case LiabilityTypeMortgage:
		*s = LiabilityTypeMortgage
	default:
		*s = LiabilityType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LiabilityType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LiabilityType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LinkType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LinkType) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("inward")
		e.Str(s.Inward)
	}
	{
		e.FieldStart("outward")
		e.Str(s.Outward)
	}
	{
		if s.Editable.Set {
			e.FieldStart("editable")
			s.Editable.Encode(e)
		}
	}
}

var jsonFieldsNameOfLinkType = [4]string{
	0: "name",
	1: "inward",
	2: "outward",
	3: "editable",
}

// Decode decodes LinkType from json.
func (s *LinkType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LinkType to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "inward":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Inward = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inward\"")
			}
		case "outward":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Outward = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outward\"")
			}
		case "editable":
			if err := func() error {
				s.Editable.Reset()
				if err := s.Editable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"editable\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LinkType")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLinkType) {
					name = jsonFieldsNameOfLinkType[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LinkType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LinkType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LinkTypeArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LinkTypeArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfLinkTypeArray = [3]string{
	0: "data",
	1: "meta",
	2: "links",
}

// Decode decodes LinkTypeArray from json.
func (s *LinkTypeArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LinkTypeArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]LinkTypeRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LinkTypeRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LinkTypeArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLinkTypeArray) {
					name = jsonFieldsNameOfLinkTypeArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LinkTypeArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LinkTypeArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LinkTypeRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LinkTypeRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfLinkTypeRead = [4]string{
	0: "type",
	1: "id",
	2: "attributes",
	3: "links",
}

// Decode decodes LinkTypeRead from json.
func (s *LinkTypeRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LinkTypeRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LinkTypeRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLinkTypeRead) {
					name = jsonFieldsNameOfLinkTypeRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LinkTypeRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LinkTypeRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LinkTypeSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LinkTypeSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfLinkTypeSingle = [1]string{
	0: "data",
}

// Decode decodes LinkTypeSingle from json.
func (s *LinkTypeSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LinkTypeSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LinkTypeSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLinkTypeSingle) {
					name = jsonFieldsNameOfLinkTypeSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LinkTypeSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LinkTypeSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LinkTypeUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LinkTypeUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Inward.Set {
			e.FieldStart("inward")
			s.Inward.Encode(e)
		}
	}
	{
		if s.Outward.Set {
			e.FieldStart("outward")
			s.Outward.Encode(e)
		}
	}
}

var jsonFieldsNameOfLinkTypeUpdate = [3]string{
	0: "name",
	1: "inward",
	2: "outward",
}

// Decode decodes LinkTypeUpdate from json.
func (s *LinkTypeUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LinkTypeUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "inward":
			if err := func() error {
				s.Inward.Reset()
				if err := s.Inward.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inward\"")
			}
		case "outward":
			if err := func() error {
				s.Outward.Reset()
				if err := s.Outward.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outward\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LinkTypeUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LinkTypeUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LinkTypeUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Meta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Meta) encodeFields(e *jx.Encoder) {
	{
		if s.Pagination.Set {
			e.FieldStart("pagination")
			s.Pagination.Encode(e)
		}
	}
}

var jsonFieldsNameOfMeta = [1]string{
	0: "pagination",
}

// Decode decodes Meta from json.
func (s *Meta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Meta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pagination":
			if err := func() error {
				s.Pagination.Reset()
				if err := s.Pagination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pagination\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Meta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Meta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Meta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MetaPagination) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MetaPagination) encodeFields(e *jx.Encoder) {
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Count.Set {
			e.FieldStart("count")
			s.Count.Encode(e)
		}
	}
	{
		if s.PerPage.Set {
			e.FieldStart("per_page")
			s.PerPage.Encode(e)
		}
	}
	{
		if s.CurrentPage.Set {
			e.FieldStart("current_page")
			s.CurrentPage.Encode(e)
		}
	}
	{
		if s.TotalPages.Set {
			e.FieldStart("total_pages")
			s.TotalPages.Encode(e)
		}
	}
}

var jsonFieldsNameOfMetaPagination = [5]string{
	0: "total",
	1: "count",
	2: "per_page",
	3: "current_page",
	4: "total_pages",
}

// Decode decodes MetaPagination from json.
func (s *MetaPagination) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MetaPagination to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "count":
			if err := func() error {
				s.Count.Reset()
				if err := s.Count.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "per_page":
			if err := func() error {
				s.PerPage.Reset()
				if err := s.PerPage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"per_page\"")
			}
		case "current_page":
			if err := func() error {
				s.CurrentPage.Reset()
				if err := s.CurrentPage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_page\"")
			}
		case "total_pages":
			if err := func() error {
				s.TotalPages.Reset()
				if err := s.TotalPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MetaPagination")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MetaPagination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MetaPagination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o NilDate) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *NilDate) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilDate to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDate)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDate)
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotFound) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Exception.Set {
			e.FieldStart("exception")
			s.Exception.Encode(e)
		}
	}
}

var jsonFieldsNameOfNotFound = [2]string{
	0: "message",
	1: "exception",
}

// Decode decodes NotFound from json.
func (s *NotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotFound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "exception":
			if err := func() error {
				s.Exception.Reset()
				if err := s.Exception.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exception\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotFound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ObjectGroup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ObjectGroup) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("order")
		e.Int32(s.Order)
	}
}

var jsonFieldsNameOfObjectGroup = [4]string{
	0: "created_at",
	1: "updated_at",
	2: "title",
	3: "order",
}

// Decode decodes ObjectGroup from json.
func (s *ObjectGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectGroup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "order":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Order = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ObjectGroup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfObjectGroup) {
					name = jsonFieldsNameOfObjectGroup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ObjectGroup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectGroup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ObjectGroupArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ObjectGroupArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
}

var jsonFieldsNameOfObjectGroupArray = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes ObjectGroupArray from json.
func (s *ObjectGroupArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectGroupArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]ObjectGroupRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ObjectGroupRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ObjectGroupArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfObjectGroupArray) {
					name = jsonFieldsNameOfObjectGroupArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ObjectGroupArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectGroupArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ObjectGroupRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ObjectGroupRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
}

var jsonFieldsNameOfObjectGroupRead = [3]string{
	0: "type",
	1: "id",
	2: "attributes",
}

// Decode decodes ObjectGroupRead from json.
func (s *ObjectGroupRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectGroupRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ObjectGroupRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfObjectGroupRead) {
					name = jsonFieldsNameOfObjectGroupRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ObjectGroupRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectGroupRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ObjectGroupSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ObjectGroupSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfObjectGroupSingle = [1]string{
	0: "data",
}

// Decode decodes ObjectGroupSingle from json.
func (s *ObjectGroupSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectGroupSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ObjectGroupSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfObjectGroupSingle) {
					name = jsonFieldsNameOfObjectGroupSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ObjectGroupSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectGroupSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ObjectGroupUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ObjectGroupUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
}

var jsonFieldsNameOfObjectGroupUpdate = [2]string{
	0: "title",
	1: "order",
}

// Decode decodes ObjectGroupUpdate from json.
func (s *ObjectGroupUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectGroupUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ObjectGroupUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfObjectGroupUpdate) {
					name = jsonFieldsNameOfObjectGroupUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ObjectGroupUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectGroupUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ObjectLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ObjectLink) encodeFields(e *jx.Encoder) {
	{
		if s.R0.Set {
			e.FieldStart("0")
			s.R0.Encode(e)
		}
	}
	{
		if s.Self.Set {
			e.FieldStart("self")
			s.Self.Encode(e)
		}
	}
}

var jsonFieldsNameOfObjectLink = [2]string{
	0: "0",
	1: "self",
}

// Decode decodes ObjectLink from json.
func (s *ObjectLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectLink to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "0":
			if err := func() error {
				s.R0.Reset()
				if err := s.R0.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"0\"")
			}
		case "self":
			if err := func() error {
				s.Self.Reset()
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ObjectLink")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ObjectLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ObjectLink0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ObjectLink0) encodeFields(e *jx.Encoder) {
	{
		if s.Rel.Set {
			e.FieldStart("rel")
			s.Rel.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfObjectLink0 = [2]string{
	0: "rel",
	1: "uri",
}

// Decode decodes ObjectLink0 from json.
func (s *ObjectLink0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectLink0 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rel":
			if err := func() error {
				s.Rel.Reset()
				if err := s.Rel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rel\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ObjectLink0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ObjectLink0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectLink0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountTypeProperty as json.
func (o OptAccountTypeProperty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AccountTypeProperty from json.
func (o *OptAccountTypeProperty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAccountTypeProperty to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAccountTypeProperty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAccountTypeProperty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BillRepeatFrequency as json.
func (o OptBillRepeatFrequency) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BillRepeatFrequency from json.
func (o *OptBillRepeatFrequency) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBillRepeatFrequency to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBillRepeatFrequency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBillRepeatFrequency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChartDataSetEntries as json.
func (o OptChartDataSetEntries) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChartDataSetEntries from json.
func (o *OptChartDataSetEntries) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChartDataSetEntries to nil")
	}
	o.Set = true
	o.Value = make(ChartDataSetEntries)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChartDataSetEntries) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChartDataSetEntries) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CronResultRow as json.
func (o OptCronResultRow) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CronResultRow from json.
func (o *OptCronResultRow) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCronResultRow to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCronResultRow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCronResultRow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CurrencyUpdateDefault as json.
func (o OptCurrencyUpdateDefault) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes CurrencyUpdateDefault from json.
func (o *OptCurrencyUpdateDefault) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCurrencyUpdateDefault to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCurrencyUpdateDefault) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCurrencyUpdateDefault) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDate) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDate) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDate to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDate)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDate)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MetaPagination as json.
func (o OptMetaPagination) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MetaPagination from json.
func (o *OptMetaPagination) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMetaPagination to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMetaPagination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMetaPagination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccountRoleProperty as json.
func (o OptNilAccountRoleProperty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AccountRoleProperty from json.
func (o *OptNilAccountRoleProperty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilAccountRoleProperty to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v AccountRoleProperty
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilAccountRoleProperty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilAccountRoleProperty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutoBudgetPeriod as json.
func (o OptNilAutoBudgetPeriod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AutoBudgetPeriod from json.
func (o *OptNilAutoBudgetPeriod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilAutoBudgetPeriod to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v AutoBudgetPeriod
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilAutoBudgetPeriod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilAutoBudgetPeriod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutoBudgetType as json.
func (o OptNilAutoBudgetType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AutoBudgetType from json.
func (o *OptNilAutoBudgetType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilAutoBudgetType to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v AutoBudgetType
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilAutoBudgetType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilAutoBudgetType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptNilBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptNilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBool to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v bool
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreditCardType as json.
func (o OptNilCreditCardType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreditCardType from json.
func (o *OptNilCreditCardType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCreditCardType to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreditCardType
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCreditCardType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCreditCardType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptNilDate) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilDate) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilDate to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDate)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDate)
}

// Encode encodes time.Time as json.
func (o OptNilDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilDateTime to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float32 as json.
func (o OptNilFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptNilFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFloat32 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float32
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptNilFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptNilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptNilInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptNilInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt32 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int32
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InterestPeriod as json.
func (o OptNilInterestPeriod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InterestPeriod from json.
func (o *OptNilInterestPeriod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInterestPeriod to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v InterestPeriod
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInterestPeriod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInterestPeriod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LiabilityDirection as json.
func (o OptNilLiabilityDirection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LiabilityDirection from json.
func (o *OptNilLiabilityDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilLiabilityDirection to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v LiabilityDirection
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilLiabilityDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilLiabilityDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LiabilityType as json.
func (o OptNilLiabilityType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LiabilityType from json.
func (o *OptNilLiabilityType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilLiabilityType to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v LiabilityType
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilLiabilityType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilLiabilityType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []string as json.
func (o OptNilStringArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes []string from json.
func (o *OptNilStringArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilStringArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]string, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem string
		v, err := d.Str()
		elem = string(v)
		if err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilStringArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilStringArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserBlockedCodeProperty as json.
func (o OptNilUserBlockedCodeProperty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserBlockedCodeProperty from json.
func (o *OptNilUserBlockedCodeProperty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUserBlockedCodeProperty to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UserBlockedCodeProperty
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUserBlockedCodeProperty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUserBlockedCodeProperty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserRoleProperty as json.
func (o OptNilUserRoleProperty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserRoleProperty from json.
func (o *OptNilUserRoleProperty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUserRoleProperty to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UserRoleProperty
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUserRoleProperty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUserRoleProperty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ObjectLink0 as json.
func (o OptObjectLink0) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ObjectLink0 from json.
func (o *OptObjectLink0) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptObjectLink0 to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptObjectLink0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptObjectLink0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecurrenceRepetitionType as json.
func (o OptRecurrenceRepetitionType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RecurrenceRepetitionType from json.
func (o *OptRecurrenceRepetitionType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRecurrenceRepetitionType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRecurrenceRepetitionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRecurrenceRepetitionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecurrenceTransactionType as json.
func (o OptRecurrenceTransactionType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RecurrenceTransactionType from json.
func (o *OptRecurrenceTransactionType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRecurrenceTransactionType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRecurrenceTransactionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRecurrenceTransactionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleActionKeyword as json.
func (o OptRuleActionKeyword) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RuleActionKeyword from json.
func (o *OptRuleActionKeyword) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRuleActionKeyword to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRuleActionKeyword) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRuleActionKeyword) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleTriggerKeyword as json.
func (o OptRuleTriggerKeyword) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RuleTriggerKeyword from json.
func (o *OptRuleTriggerKeyword) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRuleTriggerKeyword to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRuleTriggerKeyword) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRuleTriggerKeyword) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleTriggerType as json.
func (o OptRuleTriggerType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RuleTriggerType from json.
func (o *OptRuleTriggerType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRuleTriggerType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRuleTriggerType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRuleTriggerType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SystemInfoData as json.
func (o OptSystemInfoData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SystemInfoData from json.
func (o *OptSystemInfoData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSystemInfoData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSystemInfoData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSystemInfoData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransactionTypeProperty as json.
func (o OptTransactionTypeProperty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransactionTypeProperty from json.
func (o *OptTransactionTypeProperty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransactionTypeProperty to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransactionTypeProperty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransactionTypeProperty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURI to nil")
	}
	o.Set = true
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidationErrorErrors as json.
func (o OptValidationErrorErrors) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ValidationErrorErrors from json.
func (o *OptValidationErrorErrors) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptValidationErrorErrors to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptValidationErrorErrors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptValidationErrorErrors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookDelivery as json.
func (o OptWebhookDelivery) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes WebhookDelivery from json.
func (o *OptWebhookDelivery) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookDelivery to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookDelivery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookDelivery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookResponse as json.
func (o OptWebhookResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes WebhookResponse from json.
func (o *OptWebhookResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookTrigger as json.
func (o OptWebhookTrigger) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes WebhookTrigger from json.
func (o *OptWebhookTrigger) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookTrigger to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookTrigger) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookTrigger) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PageLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PageLink) encodeFields(e *jx.Encoder) {
	{
		if s.Self.Set {
			e.FieldStart("self")
			s.Self.Encode(e)
		}
	}
	{
		if s.First.Set {
			e.FieldStart("first")
			s.First.Encode(e)
		}
	}
	{
		if s.Next.Set {
			e.FieldStart("next")
			s.Next.Encode(e)
		}
	}
	{
		if s.Prev.Set {
			e.FieldStart("prev")
			s.Prev.Encode(e)
		}
	}
	{
		if s.Last.Set {
			e.FieldStart("last")
			s.Last.Encode(e)
		}
	}
}

var jsonFieldsNameOfPageLink = [5]string{
	0: "self",
	1: "first",
	2: "next",
	3: "prev",
	4: "last",
}

// Decode decodes PageLink from json.
func (s *PageLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PageLink to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "self":
			if err := func() error {
				s.Self.Reset()
				if err := s.Self.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"self\"")
			}
		case "first":
			if err := func() error {
				s.First.Reset()
				if err := s.First.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first\"")
			}
		case "next":
			if err := func() error {
				s.Next.Reset()
				if err := s.Next.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next\"")
			}
		case "prev":
			if err := func() error {
				s.Prev.Reset()
				if err := s.Prev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prev\"")
			}
		case "last":
			if err := func() error {
				s.Last.Reset()
				if err := s.Last.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PageLink")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PageLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PageLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PiggyBank) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PiggyBank) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("account_id")
		e.Str(s.AccountID)
	}
	{
		if s.AccountName.Set {
			e.FieldStart("account_name")
			s.AccountName.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.CurrencySymbol.Set {
			e.FieldStart("currency_symbol")
			s.CurrencySymbol.Encode(e)
		}
	}
	{
		if s.CurrencyDecimalPlaces.Set {
			e.FieldStart("currency_decimal_places")
			s.CurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		e.FieldStart("target_amount")
		s.TargetAmount.Encode(e)
	}
	{
		if s.Percentage.Set {
			e.FieldStart("percentage")
			s.Percentage.Encode(e)
		}
	}
	{
		if s.CurrentAmount.Set {
			e.FieldStart("current_amount")
			s.CurrentAmount.Encode(e)
		}
	}
	{
		if s.LeftToSave.Set {
			e.FieldStart("left_to_save")
			s.LeftToSave.Encode(e)
		}
	}
	{
		if s.SavePerMonth.Set {
			e.FieldStart("save_per_month")
			s.SavePerMonth.Encode(e)
		}
	}
	{
		if s.StartDate.Set {
			e.FieldStart("start_date")
			s.StartDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.TargetDate.Set {
			e.FieldStart("target_date")
			s.TargetDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.ObjectGroupID.Set {
			e.FieldStart("object_group_id")
			s.ObjectGroupID.Encode(e)
		}
	}
	{
		if s.ObjectGroupOrder.Set {
			e.FieldStart("object_group_order")
			s.ObjectGroupOrder.Encode(e)
		}
	}
	{
		if s.ObjectGroupTitle.Set {
			e.FieldStart("object_group_title")
			s.ObjectGroupTitle.Encode(e)
		}
	}
}

var jsonFieldsNameOfPiggyBank = [22]string{
	0:  "created_at",
	1:  "updated_at",
	2:  "account_id",
	3:  "account_name",
	4:  "name",
	5:  "currency_id",
	6:  "currency_code",
	7:  "currency_symbol",
	8:  "currency_decimal_places",
	9:  "target_amount",
	10: "percentage",
	11: "current_amount",
	12: "left_to_save",
	13: "save_per_month",
	14: "start_date",
	15: "target_date",
	16: "order",
	17: "active",
	18: "notes",
	19: "object_group_id",
	20: "object_group_order",
	21: "object_group_title",
}

// Decode decodes PiggyBank from json.
func (s *PiggyBank) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PiggyBank to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "account_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AccountID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_id\"")
			}
		case "account_name":
			if err := func() error {
				s.AccountName.Reset()
				if err := s.AccountName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_name\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "currency_symbol":
			if err := func() error {
				s.CurrencySymbol.Reset()
				if err := s.CurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_symbol\"")
			}
		case "currency_decimal_places":
			if err := func() error {
				s.CurrencyDecimalPlaces.Reset()
				if err := s.CurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_decimal_places\"")
			}
		case "target_amount":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.TargetAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_amount\"")
			}
		case "percentage":
			if err := func() error {
				s.Percentage.Reset()
				if err := s.Percentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"percentage\"")
			}
		case "current_amount":
			if err := func() error {
				s.CurrentAmount.Reset()
				if err := s.CurrentAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_amount\"")
			}
		case "left_to_save":
			if err := func() error {
				s.LeftToSave.Reset()
				if err := s.LeftToSave.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"left_to_save\"")
			}
		case "save_per_month":
			if err := func() error {
				s.SavePerMonth.Reset()
				if err := s.SavePerMonth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"save_per_month\"")
			}
		case "start_date":
			if err := func() error {
				s.StartDate.Reset()
				if err := s.StartDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_date\"")
			}
		case "target_date":
			if err := func() error {
				s.TargetDate.Reset()
				if err := s.TargetDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_date\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "object_group_id":
			if err := func() error {
				s.ObjectGroupID.Reset()
				if err := s.ObjectGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_id\"")
			}
		case "object_group_order":
			if err := func() error {
				s.ObjectGroupOrder.Reset()
				if err := s.ObjectGroupOrder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_order\"")
			}
		case "object_group_title":
			if err := func() error {
				s.ObjectGroupTitle.Reset()
				if err := s.ObjectGroupTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PiggyBank")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00010100,
		0b00000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPiggyBank) {
					name = jsonFieldsNameOfPiggyBank[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PiggyBank) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PiggyBank) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PiggyBankArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PiggyBankArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfPiggyBankArray = [3]string{
	0: "data",
	1: "meta",
	2: "links",
}

// Decode decodes PiggyBankArray from json.
func (s *PiggyBankArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PiggyBankArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]PiggyBankRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PiggyBankRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PiggyBankArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPiggyBankArray) {
					name = jsonFieldsNameOfPiggyBankArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PiggyBankArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PiggyBankArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PiggyBankEvent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PiggyBankEvent) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.CurrencySymbol.Set {
			e.FieldStart("currency_symbol")
			s.CurrencySymbol.Encode(e)
		}
	}
	{
		if s.CurrencyDecimalPlaces.Set {
			e.FieldStart("currency_decimal_places")
			s.CurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.TransactionJournalID.Set {
			e.FieldStart("transaction_journal_id")
			s.TransactionJournalID.Encode(e)
		}
	}
	{
		if s.TransactionGroupID.Set {
			e.FieldStart("transaction_group_id")
			s.TransactionGroupID.Encode(e)
		}
	}
}

var jsonFieldsNameOfPiggyBankEvent = [9]string{
	0: "created_at",
	1: "updated_at",
	2: "currency_id",
	3: "currency_code",
	4: "currency_symbol",
	5: "currency_decimal_places",
	6: "amount",
	7: "transaction_journal_id",
	8: "transaction_group_id",
}

// Decode decodes PiggyBankEvent from json.
func (s *PiggyBankEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PiggyBankEvent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "currency_symbol":
			if err := func() error {
				s.CurrencySymbol.Reset()
				if err := s.CurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_symbol\"")
			}
		case "currency_decimal_places":
			if err := func() error {
				s.CurrencyDecimalPlaces.Reset()
				if err := s.CurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_decimal_places\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "transaction_journal_id":
			if err := func() error {
				s.TransactionJournalID.Reset()
				if err := s.TransactionJournalID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transaction_journal_id\"")
			}
		case "transaction_group_id":
			if err := func() error {
				s.TransactionGroupID.Reset()
				if err := s.TransactionGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transaction_group_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PiggyBankEvent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PiggyBankEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PiggyBankEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PiggyBankEventArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PiggyBankEventArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfPiggyBankEventArray = [3]string{
	0: "data",
	1: "meta",
	2: "links",
}

// Decode decodes PiggyBankEventArray from json.
func (s *PiggyBankEventArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PiggyBankEventArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]PiggyBankEventRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PiggyBankEventRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PiggyBankEventArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPiggyBankEventArray) {
					name = jsonFieldsNameOfPiggyBankEventArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PiggyBankEventArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PiggyBankEventArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PiggyBankEventRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PiggyBankEventRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfPiggyBankEventRead = [4]string{
	0: "type",
	1: "id",
	2: "attributes",
	3: "links",
}

// Decode decodes PiggyBankEventRead from json.
func (s *PiggyBankEventRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PiggyBankEventRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PiggyBankEventRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPiggyBankEventRead) {
					name = jsonFieldsNameOfPiggyBankEventRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PiggyBankEventRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PiggyBankEventRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PiggyBankRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PiggyBankRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfPiggyBankRead = [4]string{
	0: "type",
	1: "id",
	2: "attributes",
	3: "links",
}

// Decode decodes PiggyBankRead from json.
func (s *PiggyBankRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PiggyBankRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PiggyBankRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPiggyBankRead) {
					name = jsonFieldsNameOfPiggyBankRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PiggyBankRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PiggyBankRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PiggyBankSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PiggyBankSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfPiggyBankSingle = [1]string{
	0: "data",
}

// Decode decodes PiggyBankSingle from json.
func (s *PiggyBankSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PiggyBankSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PiggyBankSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPiggyBankSingle) {
					name = jsonFieldsNameOfPiggyBankSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PiggyBankSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PiggyBankSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PiggyBankStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PiggyBankStore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("account_id")
		e.Str(s.AccountID)
	}
	{
		e.FieldStart("target_amount")
		s.TargetAmount.Encode(e)
	}
	{
		if s.CurrentAmount.Set {
			e.FieldStart("current_amount")
			s.CurrentAmount.Encode(e)
		}
	}
	{
		if s.StartDate.Set {
			e.FieldStart("start_date")
			s.StartDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.TargetDate.Set {
			e.FieldStart("target_date")
			s.TargetDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.ObjectGroupID.Set {
			e.FieldStart("object_group_id")
			s.ObjectGroupID.Encode(e)
		}
	}
	{
		if s.ObjectGroupTitle.Set {
			e.FieldStart("object_group_title")
			s.ObjectGroupTitle.Encode(e)
		}
	}
}

var jsonFieldsNameOfPiggyBankStore = [11]string{
	0:  "name",
	1:  "account_id",
	2:  "target_amount",
	3:  "current_amount",
	4:  "start_date",
	5:  "target_date",
	6:  "order",
	7:  "active",
	8:  "notes",
	9:  "object_group_id",
	10: "object_group_title",
}

// Decode decodes PiggyBankStore from json.
func (s *PiggyBankStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PiggyBankStore to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AccountID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_id\"")
			}
		case "target_amount":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.TargetAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_amount\"")
			}
		case "current_amount":
			if err := func() error {
				s.CurrentAmount.Reset()
				if err := s.CurrentAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_amount\"")
			}
		case "start_date":
			if err := func() error {
				s.StartDate.Reset()
				if err := s.StartDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_date\"")
			}
		case "target_date":
			if err := func() error {
				s.TargetDate.Reset()
				if err := s.TargetDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_date\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "object_group_id":
			if err := func() error {
				s.ObjectGroupID.Reset()
				if err := s.ObjectGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_id\"")
			}
		case "object_group_title":
			if err := func() error {
				s.ObjectGroupTitle.Reset()
				if err := s.ObjectGroupTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PiggyBankStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPiggyBankStore) {
					name = jsonFieldsNameOfPiggyBankStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PiggyBankStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PiggyBankStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PiggyBankUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PiggyBankUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.AccountID.Set {
			e.FieldStart("account_id")
			s.AccountID.Encode(e)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.TargetAmount.Set {
			e.FieldStart("target_amount")
			s.TargetAmount.Encode(e)
		}
	}
	{
		if s.CurrentAmount.Set {
			e.FieldStart("current_amount")
			s.CurrentAmount.Encode(e)
		}
	}
	{
		if s.StartDate.Set {
			e.FieldStart("start_date")
			s.StartDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.TargetDate.Set {
			e.FieldStart("target_date")
			s.TargetDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.ObjectGroupID.Set {
			e.FieldStart("object_group_id")
			s.ObjectGroupID.Encode(e)
		}
	}
	{
		if s.ObjectGroupTitle.Set {
			e.FieldStart("object_group_title")
			s.ObjectGroupTitle.Encode(e)
		}
	}
}

var jsonFieldsNameOfPiggyBankUpdate = [13]string{
	0:  "name",
	1:  "account_id",
	2:  "currency_id",
	3:  "currency_code",
	4:  "target_amount",
	5:  "current_amount",
	6:  "start_date",
	7:  "target_date",
	8:  "order",
	9:  "active",
	10: "notes",
	11: "object_group_id",
	12: "object_group_title",
}

// Decode decodes PiggyBankUpdate from json.
func (s *PiggyBankUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PiggyBankUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "account_id":
			if err := func() error {
				s.AccountID.Reset()
				if err := s.AccountID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"account_id\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "target_amount":
			if err := func() error {
				s.TargetAmount.Reset()
				if err := s.TargetAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_amount\"")
			}
		case "current_amount":
			if err := func() error {
				s.CurrentAmount.Reset()
				if err := s.CurrentAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_amount\"")
			}
		case "start_date":
			if err := func() error {
				s.StartDate.Reset()
				if err := s.StartDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_date\"")
			}
		case "target_date":
			if err := func() error {
				s.TargetDate.Reset()
				if err := s.TargetDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_date\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "object_group_id":
			if err := func() error {
				s.ObjectGroupID.Reset()
				if err := s.ObjectGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_id\"")
			}
		case "object_group_title":
			if err := func() error {
				s.ObjectGroupTitle.Reset()
				if err := s.ObjectGroupTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"object_group_title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PiggyBankUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PiggyBankUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PiggyBankUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PolymorphicProperty as json.
func (s PolymorphicProperty) Encode(e *jx.Encoder) {
	switch s.Type {
	case BoolPolymorphicProperty:
		e.Bool(s.Bool)
	case StringPolymorphicProperty:
		e.Str(s.String)
	case PolymorphicProperty2PolymorphicProperty:
		s.PolymorphicProperty2.Encode(e)
	case StringArrayItemArrayPolymorphicProperty:
		e.ArrStart()
		for _, elem := range s.StringArrayItemArray {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes PolymorphicProperty from json.
func (s *PolymorphicProperty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PolymorphicProperty to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArrayItemArray = make([]StringArrayItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem StringArrayItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.StringArrayItemArray = append(s.StringArrayItemArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayItemArrayPolymorphicProperty
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolPolymorphicProperty
	case jx.Object:
		if err := s.PolymorphicProperty2.Decode(d); err != nil {
			return err
		}
		s.Type = PolymorphicProperty2PolymorphicProperty
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringPolymorphicProperty
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PolymorphicProperty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PolymorphicProperty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PolymorphicProperty2) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PolymorphicProperty2) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfPolymorphicProperty2 = [0]string{}

// Decode decodes PolymorphicProperty2 from json.
func (s *PolymorphicProperty2) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PolymorphicProperty2 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode PolymorphicProperty2")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PolymorphicProperty2) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PolymorphicProperty2) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Preference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Preference) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfPreference = [4]string{
	0: "created_at",
	1: "updated_at",
	2: "name",
	3: "data",
}

// Decode decodes Preference from json.
func (s *Preference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Preference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "data":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Preference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPreference) {
					name = jsonFieldsNameOfPreference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Preference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Preference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PreferenceArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PreferenceArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfPreferenceArray = [3]string{
	0: "data",
	1: "meta",
	2: "links",
}

// Decode decodes PreferenceArray from json.
func (s *PreferenceArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PreferenceArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]PreferenceRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PreferenceRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PreferenceArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPreferenceArray) {
					name = jsonFieldsNameOfPreferenceArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PreferenceArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PreferenceArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PreferenceRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PreferenceRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
}

var jsonFieldsNameOfPreferenceRead = [3]string{
	0: "type",
	1: "id",
	2: "attributes",
}

// Decode decodes PreferenceRead from json.
func (s *PreferenceRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PreferenceRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PreferenceRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPreferenceRead) {
					name = jsonFieldsNameOfPreferenceRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PreferenceRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PreferenceRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PreferenceSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PreferenceSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfPreferenceSingle = [1]string{
	0: "data",
}

// Decode decodes PreferenceSingle from json.
func (s *PreferenceSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PreferenceSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PreferenceSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPreferenceSingle) {
					name = jsonFieldsNameOfPreferenceSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PreferenceSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PreferenceSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PreferenceUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PreferenceUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfPreferenceUpdate = [1]string{
	0: "data",
}

// Decode decodes PreferenceUpdate from json.
func (s *PreferenceUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PreferenceUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PreferenceUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPreferenceUpdate) {
					name = jsonFieldsNameOfPreferenceUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PreferenceUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PreferenceUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Recurrence) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Recurrence) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.FirstDate.Set {
			e.FieldStart("first_date")
			s.FirstDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.LatestDate.Set {
			e.FieldStart("latest_date")
			s.LatestDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.RepeatUntil.Set {
			e.FieldStart("repeat_until")
			s.RepeatUntil.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.NrOfRepetitions.Set {
			e.FieldStart("nr_of_repetitions")
			s.NrOfRepetitions.Encode(e)
		}
	}
	{
		if s.ApplyRules.Set {
			e.FieldStart("apply_rules")
			s.ApplyRules.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.Repetitions != nil {
			e.FieldStart("repetitions")
			e.ArrStart()
			for _, elem := range s.Repetitions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Transactions != nil {
			e.FieldStart("transactions")
			e.ArrStart()
			for _, elem := range s.Transactions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRecurrence = [14]string{
	0:  "created_at",
	1:  "updated_at",
	2:  "type",
	3:  "title",
	4:  "description",
	5:  "first_date",
	6:  "latest_date",
	7:  "repeat_until",
	8:  "nr_of_repetitions",
	9:  "apply_rules",
	10: "active",
	11: "notes",
	12: "repetitions",
	13: "transactions",
}

// Decode decodes Recurrence from json.
func (s *Recurrence) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Recurrence to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "first_date":
			if err := func() error {
				s.FirstDate.Reset()
				if err := s.FirstDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_date\"")
			}
		case "latest_date":
			if err := func() error {
				s.LatestDate.Reset()
				if err := s.LatestDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_date\"")
			}
		case "repeat_until":
			if err := func() error {
				s.RepeatUntil.Reset()
				if err := s.RepeatUntil.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repeat_until\"")
			}
		case "nr_of_repetitions":
			if err := func() error {
				s.NrOfRepetitions.Reset()
				if err := s.NrOfRepetitions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nr_of_repetitions\"")
			}
		case "apply_rules":
			if err := func() error {
				s.ApplyRules.Reset()
				if err := s.ApplyRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apply_rules\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "repetitions":
			if err := func() error {
				s.Repetitions = make([]RecurrenceRepetition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RecurrenceRepetition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repetitions = append(s.Repetitions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repetitions\"")
			}
		case "transactions":
			if err := func() error {
				s.Transactions = make([]RecurrenceTransaction, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RecurrenceTransaction
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Transactions = append(s.Transactions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Recurrence")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Recurrence) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Recurrence) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecurrenceArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecurrenceArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfRecurrenceArray = [3]string{
	0: "data",
	1: "meta",
	2: "links",
}

// Decode decodes RecurrenceArray from json.
func (s *RecurrenceArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecurrenceArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]RecurrenceRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RecurrenceRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecurrenceArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecurrenceArray) {
					name = jsonFieldsNameOfRecurrenceArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecurrenceArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecurrenceArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecurrenceRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecurrenceRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfRecurrenceRead = [4]string{
	0: "type",
	1: "id",
	2: "attributes",
	3: "links",
}

// Decode decodes RecurrenceRead from json.
func (s *RecurrenceRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecurrenceRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecurrenceRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecurrenceRead) {
					name = jsonFieldsNameOfRecurrenceRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecurrenceRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecurrenceRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecurrenceRepetition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecurrenceRepetition) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("moment")
		e.Str(s.Moment)
	}
	{
		if s.Skip.Set {
			e.FieldStart("skip")
			s.Skip.Encode(e)
		}
	}
	{
		if s.Weekend.Set {
			e.FieldStart("weekend")
			s.Weekend.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Occurrences != nil {
			e.FieldStart("occurrences")
			e.ArrStart()
			for _, elem := range s.Occurrences {
				json.EncodeDateTime(e, elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRecurrenceRepetition = [9]string{
	0: "id",
	1: "created_at",
	2: "updated_at",
	3: "type",
	4: "moment",
	5: "skip",
	6: "weekend",
	7: "description",
	8: "occurrences",
}

// Decode decodes RecurrenceRepetition from json.
func (s *RecurrenceRepetition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecurrenceRepetition to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "moment":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Moment = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moment\"")
			}
		case "skip":
			if err := func() error {
				s.Skip.Reset()
				if err := s.Skip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skip\"")
			}
		case "weekend":
			if err := func() error {
				s.Weekend.Reset()
				if err := s.Weekend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weekend\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "occurrences":
			if err := func() error {
				s.Occurrences = make([]time.Time, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem time.Time
					v, err := json.DecodeDateTime(d)
					elem = v
					if err != nil {
						return err
					}
					s.Occurrences = append(s.Occurrences, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"occurrences\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecurrenceRepetition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecurrenceRepetition) {
					name = jsonFieldsNameOfRecurrenceRepetition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecurrenceRepetition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecurrenceRepetition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecurrenceRepetitionStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecurrenceRepetitionStore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("moment")
		e.Str(s.Moment)
	}
	{
		if s.Skip.Set {
			e.FieldStart("skip")
			s.Skip.Encode(e)
		}
	}
	{
		if s.Weekend.Set {
			e.FieldStart("weekend")
			s.Weekend.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecurrenceRepetitionStore = [4]string{
	0: "type",
	1: "moment",
	2: "skip",
	3: "weekend",
}

// Decode decodes RecurrenceRepetitionStore from json.
func (s *RecurrenceRepetitionStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecurrenceRepetitionStore to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "moment":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Moment = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moment\"")
			}
		case "skip":
			if err := func() error {
				s.Skip.Reset()
				if err := s.Skip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skip\"")
			}
		case "weekend":
			if err := func() error {
				s.Weekend.Reset()
				if err := s.Weekend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weekend\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecurrenceRepetitionStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecurrenceRepetitionStore) {
					name = jsonFieldsNameOfRecurrenceRepetitionStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecurrenceRepetitionStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecurrenceRepetitionStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecurrenceRepetitionType as json.
func (s RecurrenceRepetitionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecurrenceRepetitionType from json.
func (s *RecurrenceRepetitionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecurrenceRepetitionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecurrenceRepetitionType(v) {
	case RecurrenceRepetitionTypeDaily:
		*s = RecurrenceRepetitionTypeDaily
	case RecurrenceRepetitionTypeWeekly:
		*s = RecurrenceRepetitionTypeWeekly
	case RecurrenceRepetitionTypeNdom:
		*s = RecurrenceRepetitionTypeNdom
	case RecurrenceRepetitionTypeMonthly:
		*s = RecurrenceRepetitionTypeMonthly
	case RecurrenceRepetitionTypeYearly:
		*s = RecurrenceRepetitionTypeYearly
	default:
		*s = RecurrenceRepetitionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecurrenceRepetitionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecurrenceRepetitionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecurrenceRepetitionUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecurrenceRepetitionUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Moment.Set {
			e.FieldStart("moment")
			s.Moment.Encode(e)
		}
	}
	{
		if s.Skip.Set {
			e.FieldStart("skip")
			s.Skip.Encode(e)
		}
	}
	{
		if s.Weekend.Set {
			e.FieldStart("weekend")
			s.Weekend.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecurrenceRepetitionUpdate = [4]string{
	0: "type",
	1: "moment",
	2: "skip",
	3: "weekend",
}

// Decode decodes RecurrenceRepetitionUpdate from json.
func (s *RecurrenceRepetitionUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecurrenceRepetitionUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "moment":
			if err := func() error {
				s.Moment.Reset()
				if err := s.Moment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moment\"")
			}
		case "skip":
			if err := func() error {
				s.Skip.Reset()
				if err := s.Skip.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"skip\"")
			}
		case "weekend":
			if err := func() error {
				s.Weekend.Reset()
				if err := s.Weekend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weekend\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecurrenceRepetitionUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecurrenceRepetitionUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecurrenceRepetitionUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecurrenceSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecurrenceSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfRecurrenceSingle = [1]string{
	0: "data",
}

// Decode decodes RecurrenceSingle from json.
func (s *RecurrenceSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecurrenceSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecurrenceSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecurrenceSingle) {
					name = jsonFieldsNameOfRecurrenceSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecurrenceSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecurrenceSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecurrenceStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecurrenceStore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("first_date")
		json.EncodeDate(e, s.FirstDate)
	}
	{
		e.FieldStart("repeat_until")
		s.RepeatUntil.Encode(e, json.EncodeDate)
	}
	{
		if s.NrOfRepetitions.Set {
			e.FieldStart("nr_of_repetitions")
			s.NrOfRepetitions.Encode(e)
		}
	}
	{
		if s.ApplyRules.Set {
			e.FieldStart("apply_rules")
			s.ApplyRules.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		e.FieldStart("repetitions")
		e.ArrStart()
		for _, elem := range s.Repetitions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("transactions")
		e.ArrStart()
		for _, elem := range s.Transactions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRecurrenceStore = [11]string{
	0:  "type",
	1:  "title",
	2:  "description",
	3:  "first_date",
	4:  "repeat_until",
	5:  "nr_of_repetitions",
	6:  "apply_rules",
	7:  "active",
	8:  "notes",
	9:  "repetitions",
	10: "transactions",
}

// Decode decodes RecurrenceStore from json.
func (s *RecurrenceStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecurrenceStore to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "first_date":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.FirstDate = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_date\"")
			}
		case "repeat_until":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.RepeatUntil.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repeat_until\"")
			}
		case "nr_of_repetitions":
			if err := func() error {
				s.NrOfRepetitions.Reset()
				if err := s.NrOfRepetitions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nr_of_repetitions\"")
			}
		case "apply_rules":
			if err := func() error {
				s.ApplyRules.Reset()
				if err := s.ApplyRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apply_rules\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "repetitions":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				s.Repetitions = make([]RecurrenceRepetitionStore, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RecurrenceRepetitionStore
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repetitions = append(s.Repetitions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repetitions\"")
			}
		case "transactions":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.Transactions = make([]RecurrenceTransactionStore, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RecurrenceTransactionStore
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Transactions = append(s.Transactions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecurrenceStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011011,
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecurrenceStore) {
					name = jsonFieldsNameOfRecurrenceStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecurrenceStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecurrenceStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecurrenceTransaction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecurrenceTransaction) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("amount")
		e.Str(s.Amount)
	}
	{
		if s.ForeignAmount.Set {
			e.FieldStart("foreign_amount")
			s.ForeignAmount.Encode(e)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.CurrencySymbol.Set {
			e.FieldStart("currency_symbol")
			s.CurrencySymbol.Encode(e)
		}
	}
	{
		if s.CurrencyDecimalPlaces.Set {
			e.FieldStart("currency_decimal_places")
			s.CurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		if s.ForeignCurrencyID.Set {
			e.FieldStart("foreign_currency_id")
			s.ForeignCurrencyID.Encode(e)
		}
	}
	{
		if s.ForeignCurrencyCode.Set {
			e.FieldStart("foreign_currency_code")
			s.ForeignCurrencyCode.Encode(e)
		}
	}
	{
		if s.ForeignCurrencySymbol.Set {
			e.FieldStart("foreign_currency_symbol")
			s.ForeignCurrencySymbol.Encode(e)
		}
	}
	{
		if s.ForeignCurrencyDecimalPlaces.Set {
			e.FieldStart("foreign_currency_decimal_places")
			s.ForeignCurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		if s.BudgetID.Set {
			e.FieldStart("budget_id")
			s.BudgetID.Encode(e)
		}
	}
	{
		if s.BudgetName.Set {
			e.FieldStart("budget_name")
			s.BudgetName.Encode(e)
		}
	}
	{
		if s.CategoryID.Set {
			e.FieldStart("category_id")
			s.CategoryID.Encode(e)
		}
	}
	{
		if s.CategoryName.Set {
			e.FieldStart("category_name")
			s.CategoryName.Encode(e)
		}
	}
	{
		if s.SourceID.Set {
			e.FieldStart("source_id")
			s.SourceID.Encode(e)
		}
	}
	{
		if s.SourceName.Set {
			e.FieldStart("source_name")
			s.SourceName.Encode(e)
		}
	}
	{
		if s.SourceIban.Set {
			e.FieldStart("source_iban")
			s.SourceIban.Encode(e)
		}
	}
	{
		if s.SourceType.Set {
			e.FieldStart("source_type")
			s.SourceType.Encode(e)
		}
	}
	{
		if s.DestinationID.Set {
			e.FieldStart("destination_id")
			s.DestinationID.Encode(e)
		}
	}
	{
		if s.DestinationName.Set {
			e.FieldStart("destination_name")
			s.DestinationName.Encode(e)
		}
	}
	{
		if s.DestinationIban.Set {
			e.FieldStart("destination_iban")
			s.DestinationIban.Encode(e)
		}
	}
	{
		if s.DestinationType.Set {
			e.FieldStart("destination_type")
			s.DestinationType.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.PiggyBankID.Set {
			e.FieldStart("piggy_bank_id")
			s.PiggyBankID.Encode(e)
		}
	}
	{
		if s.PiggyBankName.Set {
			e.FieldStart("piggy_bank_name")
			s.PiggyBankName.Encode(e)
		}
	}
	{
		if s.BillID.Set {
			e.FieldStart("bill_id")
			s.BillID.Encode(e)
		}
	}
	{
		if s.BillName.Set {
			e.FieldStart("bill_name")
			s.BillName.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecurrenceTransaction = [29]string{
	0:  "id",
	1:  "description",
	2:  "amount",
	3:  "foreign_amount",
	4:  "currency_id",
	5:  "currency_code",
	6:  "currency_symbol",
	7:  "currency_decimal_places",
	8:  "foreign_currency_id",
	9:  "foreign_currency_code",
	10: "foreign_currency_symbol",
	11: "foreign_currency_decimal_places",
	12: "budget_id",
	13: "budget_name",
	14: "category_id",
	15: "category_name",
	16: "source_id",
	17: "source_name",
	18: "source_iban",
	19: "source_type",
	20: "destination_id",
	21: "destination_name",
	22: "destination_iban",
	23: "destination_type",
	24: "tags",
	25: "piggy_bank_id",
	26: "piggy_bank_name",
	27: "bill_id",
	28: "bill_name",
}

// Decode decodes RecurrenceTransaction from json.
func (s *RecurrenceTransaction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecurrenceTransaction to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Amount = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "foreign_amount":
			if err := func() error {
				s.ForeignAmount.Reset()
				if err := s.ForeignAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_amount\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "currency_symbol":
			if err := func() error {
				s.CurrencySymbol.Reset()
				if err := s.CurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_symbol\"")
			}
		case "currency_decimal_places":
			if err := func() error {
				s.CurrencyDecimalPlaces.Reset()
				if err := s.CurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_decimal_places\"")
			}
		case "foreign_currency_id":
			if err := func() error {
				s.ForeignCurrencyID.Reset()
				if err := s.ForeignCurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_currency_id\"")
			}
		case "foreign_currency_code":
			if err := func() error {
				s.ForeignCurrencyCode.Reset()
				if err := s.ForeignCurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_currency_code\"")
			}
		case "foreign_currency_symbol":
			if err := func() error {
				s.ForeignCurrencySymbol.Reset()
				if err := s.ForeignCurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_currency_symbol\"")
			}
		case "foreign_currency_decimal_places":
			if err := func() error {
				s.ForeignCurrencyDecimalPlaces.Reset()
				if err := s.ForeignCurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_currency_decimal_places\"")
			}
		case "budget_id":
			if err := func() error {
				s.BudgetID.Reset()
				if err := s.BudgetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"budget_id\"")
			}
		case "budget_name":
			if err := func() error {
				s.BudgetName.Reset()
				if err := s.BudgetName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"budget_name\"")
			}
		case "category_id":
			if err := func() error {
				s.CategoryID.Reset()
				if err := s.CategoryID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_id\"")
			}
		case "category_name":
			if err := func() error {
				s.CategoryName.Reset()
				if err := s.CategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_name\"")
			}
		case "source_id":
			if err := func() error {
				s.SourceID.Reset()
				if err := s.SourceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_id\"")
			}
		case "source_name":
			if err := func() error {
				s.SourceName.Reset()
				if err := s.SourceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_name\"")
			}
		case "source_iban":
			if err := func() error {
				s.SourceIban.Reset()
				if err := s.SourceIban.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_iban\"")
			}
		case "source_type":
			if err := func() error {
				s.SourceType.Reset()
				if err := s.SourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_type\"")
			}
		case "destination_id":
			if err := func() error {
				s.DestinationID.Reset()
				if err := s.DestinationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination_id\"")
			}
		case "destination_name":
			if err := func() error {
				s.DestinationName.Reset()
				if err := s.DestinationName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination_name\"")
			}
		case "destination_iban":
			if err := func() error {
				s.DestinationIban.Reset()
				if err := s.DestinationIban.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination_iban\"")
			}
		case "destination_type":
			if err := func() error {
				s.DestinationType.Reset()
				if err := s.DestinationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination_type\"")
			}
		case "tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "piggy_bank_id":
			if err := func() error {
				s.PiggyBankID.Reset()
				if err := s.PiggyBankID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"piggy_bank_id\"")
			}
		case "piggy_bank_name":
			if err := func() error {
				s.PiggyBankName.Reset()
				if err := s.PiggyBankName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"piggy_bank_name\"")
			}
		case "bill_id":
			if err := func() error {
				s.BillID.Reset()
				if err := s.BillID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bill_id\"")
			}
		case "bill_name":
			if err := func() error {
				s.BillName.Reset()
				if err := s.BillName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bill_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecurrenceTransaction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00000110,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecurrenceTransaction) {
					name = jsonFieldsNameOfRecurrenceTransaction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecurrenceTransaction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecurrenceTransaction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecurrenceTransactionStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecurrenceTransactionStore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("amount")
		e.Str(s.Amount)
	}
	{
		if s.ForeignAmount.Set {
			e.FieldStart("foreign_amount")
			s.ForeignAmount.Encode(e)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.ForeignCurrencyID.Set {
			e.FieldStart("foreign_currency_id")
			s.ForeignCurrencyID.Encode(e)
		}
	}
	{
		if s.ForeignCurrencyCode.Set {
			e.FieldStart("foreign_currency_code")
			s.ForeignCurrencyCode.Encode(e)
		}
	}
	{
		if s.BudgetID.Set {
			e.FieldStart("budget_id")
			s.BudgetID.Encode(e)
		}
	}
	{
		if s.CategoryID.Set {
			e.FieldStart("category_id")
			s.CategoryID.Encode(e)
		}
	}
	{
		e.FieldStart("source_id")
		e.Str(s.SourceID)
	}
	{
		e.FieldStart("destination_id")
		e.Str(s.DestinationID)
	}
	{
		if s.Tags.Set {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.PiggyBankID.Set {
			e.FieldStart("piggy_bank_id")
			s.PiggyBankID.Encode(e)
		}
	}
	{
		if s.BillID.Set {
			e.FieldStart("bill_id")
			s.BillID.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecurrenceTransactionStore = [14]string{
	0:  "description",
	1:  "amount",
	2:  "foreign_amount",
	3:  "currency_id",
	4:  "currency_code",
	5:  "foreign_currency_id",
	6:  "foreign_currency_code",
	7:  "budget_id",
	8:  "category_id",
	9:  "source_id",
	10: "destination_id",
	11: "tags",
	12: "piggy_bank_id",
	13: "bill_id",
}

// Decode decodes RecurrenceTransactionStore from json.
func (s *RecurrenceTransactionStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecurrenceTransactionStore to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Amount = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "foreign_amount":
			if err := func() error {
				s.ForeignAmount.Reset()
				if err := s.ForeignAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_amount\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "foreign_currency_id":
			if err := func() error {
				s.ForeignCurrencyID.Reset()
				if err := s.ForeignCurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_currency_id\"")
			}
		case "foreign_currency_code":
			if err := func() error {
				s.ForeignCurrencyCode.Reset()
				if err := s.ForeignCurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_currency_code\"")
			}
		case "budget_id":
			if err := func() error {
				s.BudgetID.Reset()
				if err := s.BudgetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"budget_id\"")
			}
		case "category_id":
			if err := func() error {
				s.CategoryID.Reset()
				if err := s.CategoryID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_id\"")
			}
		case "source_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SourceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_id\"")
			}
		case "destination_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DestinationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination_id\"")
			}
		case "tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "piggy_bank_id":
			if err := func() error {
				s.PiggyBankID.Reset()
				if err := s.PiggyBankID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"piggy_bank_id\"")
			}
		case "bill_id":
			if err := func() error {
				s.BillID.Reset()
				if err := s.BillID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bill_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecurrenceTransactionStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecurrenceTransactionStore) {
					name = jsonFieldsNameOfRecurrenceTransactionStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecurrenceTransactionStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecurrenceTransactionStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecurrenceTransactionType as json.
func (s RecurrenceTransactionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecurrenceTransactionType from json.
func (s *RecurrenceTransactionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecurrenceTransactionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecurrenceTransactionType(v) {
	case RecurrenceTransactionTypeWithdrawal:
		*s = RecurrenceTransactionTypeWithdrawal
	case RecurrenceTransactionTypeTransfer:
		*s = RecurrenceTransactionTypeTransfer
	case RecurrenceTransactionTypeDeposit:
		*s = RecurrenceTransactionTypeDeposit
	default:
		*s = RecurrenceTransactionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecurrenceTransactionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecurrenceTransactionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecurrenceTransactionUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecurrenceTransactionUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.ForeignAmount.Set {
			e.FieldStart("foreign_amount")
			s.ForeignAmount.Encode(e)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.ForeignCurrencyID.Set {
			e.FieldStart("foreign_currency_id")
			s.ForeignCurrencyID.Encode(e)
		}
	}
	{
		if s.BudgetID.Set {
			e.FieldStart("budget_id")
			s.BudgetID.Encode(e)
		}
	}
	{
		if s.CategoryID.Set {
			e.FieldStart("category_id")
			s.CategoryID.Encode(e)
		}
	}
	{
		if s.SourceID.Set {
			e.FieldStart("source_id")
			s.SourceID.Encode(e)
		}
	}
	{
		if s.DestinationID.Set {
			e.FieldStart("destination_id")
			s.DestinationID.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.PiggyBankID.Set {
			e.FieldStart("piggy_bank_id")
			s.PiggyBankID.Encode(e)
		}
	}
	{
		if s.BillID.Set {
			e.FieldStart("bill_id")
			s.BillID.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecurrenceTransactionUpdate = [14]string{
	0:  "id",
	1:  "description",
	2:  "amount",
	3:  "foreign_amount",
	4:  "currency_id",
	5:  "currency_code",
	6:  "foreign_currency_id",
	7:  "budget_id",
	8:  "category_id",
	9:  "source_id",
	10: "destination_id",
	11: "tags",
	12: "piggy_bank_id",
	13: "bill_id",
}

// Decode decodes RecurrenceTransactionUpdate from json.
func (s *RecurrenceTransactionUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecurrenceTransactionUpdate to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "foreign_amount":
			if err := func() error {
				s.ForeignAmount.Reset()
				if err := s.ForeignAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_amount\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "foreign_currency_id":
			if err := func() error {
				s.ForeignCurrencyID.Reset()
				if err := s.ForeignCurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_currency_id\"")
			}
		case "budget_id":
			if err := func() error {
				s.BudgetID.Reset()
				if err := s.BudgetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"budget_id\"")
			}
		case "category_id":
			if err := func() error {
				s.CategoryID.Reset()
				if err := s.CategoryID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_id\"")
			}
		case "source_id":
			if err := func() error {
				s.SourceID.Reset()
				if err := s.SourceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_id\"")
			}
		case "destination_id":
			if err := func() error {
				s.DestinationID.Reset()
				if err := s.DestinationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination_id\"")
			}
		case "tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "piggy_bank_id":
			if err := func() error {
				s.PiggyBankID.Reset()
				if err := s.PiggyBankID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"piggy_bank_id\"")
			}
		case "bill_id":
			if err := func() error {
				s.BillID.Reset()
				if err := s.BillID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bill_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecurrenceTransactionUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecurrenceTransactionUpdate) {
					name = jsonFieldsNameOfRecurrenceTransactionUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecurrenceTransactionUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecurrenceTransactionUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecurrenceUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecurrenceUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.FirstDate.Set {
			e.FieldStart("first_date")
			s.FirstDate.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.RepeatUntil.Set {
			e.FieldStart("repeat_until")
			s.RepeatUntil.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.NrOfRepetitions.Set {
			e.FieldStart("nr_of_repetitions")
			s.NrOfRepetitions.Encode(e)
		}
	}
	{
		if s.ApplyRules.Set {
			e.FieldStart("apply_rules")
			s.ApplyRules.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.Repetitions != nil {
			e.FieldStart("repetitions")
			e.ArrStart()
			for _, elem := range s.Repetitions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Transactions != nil {
			e.FieldStart("transactions")
			e.ArrStart()
			for _, elem := range s.Transactions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRecurrenceUpdate = [10]string{
	0: "title",
	1: "description",
	2: "first_date",
	3: "repeat_until",
	4: "nr_of_repetitions",
	5: "apply_rules",
	6: "active",
	7: "notes",
	8: "repetitions",
	9: "transactions",
}

// Decode decodes RecurrenceUpdate from json.
func (s *RecurrenceUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecurrenceUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "first_date":
			if err := func() error {
				s.FirstDate.Reset()
				if err := s.FirstDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_date\"")
			}
		case "repeat_until":
			if err := func() error {
				s.RepeatUntil.Reset()
				if err := s.RepeatUntil.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repeat_until\"")
			}
		case "nr_of_repetitions":
			if err := func() error {
				s.NrOfRepetitions.Reset()
				if err := s.NrOfRepetitions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nr_of_repetitions\"")
			}
		case "apply_rules":
			if err := func() error {
				s.ApplyRules.Reset()
				if err := s.ApplyRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apply_rules\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "repetitions":
			if err := func() error {
				s.Repetitions = make([]RecurrenceRepetitionUpdate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RecurrenceRepetitionUpdate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Repetitions = append(s.Repetitions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repetitions\"")
			}
		case "transactions":
			if err := func() error {
				s.Transactions = make([]RecurrenceTransactionUpdate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RecurrenceTransactionUpdate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Transactions = append(s.Transactions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecurrenceUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecurrenceUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecurrenceUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Rule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Rule) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("rule_group_id")
		e.Str(s.RuleGroupID)
	}
	{
		if s.RuleGroupTitle.Set {
			e.FieldStart("rule_group_title")
			s.RuleGroupTitle.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		e.FieldStart("trigger")
		s.Trigger.Encode(e)
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Strict.Set {
			e.FieldStart("strict")
			s.Strict.Encode(e)
		}
	}
	{
		if s.StopProcessing.Set {
			e.FieldStart("stop_processing")
			s.StopProcessing.Encode(e)
		}
	}
	{
		e.FieldStart("triggers")
		e.ArrStart()
		for _, elem := range s.Triggers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("actions")
		e.ArrStart()
		for _, elem := range s.Actions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRule = [13]string{
	0:  "created_at",
	1:  "updated_at",
	2:  "title",
	3:  "description",
	4:  "rule_group_id",
	5:  "rule_group_title",
	6:  "order",
	7:  "trigger",
	8:  "active",
	9:  "strict",
	10: "stop_processing",
	11: "triggers",
	12: "actions",
}

// Decode decodes Rule from json.
func (s *Rule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Rule to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "rule_group_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.RuleGroupID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule_group_id\"")
			}
		case "rule_group_title":
			if err := func() error {
				s.RuleGroupTitle.Reset()
				if err := s.RuleGroupTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule_group_title\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "trigger":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Trigger.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trigger\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "strict":
			if err := func() error {
				s.Strict.Reset()
				if err := s.Strict.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strict\"")
			}
		case "stop_processing":
			if err := func() error {
				s.StopProcessing.Reset()
				if err := s.StopProcessing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop_processing\"")
			}
		case "triggers":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.Triggers = make([]RuleTrigger, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RuleTrigger
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Triggers = append(s.Triggers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triggers\"")
			}
		case "actions":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				s.Actions = make([]RuleAction, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RuleAction
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Actions = append(s.Actions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Rule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10010100,
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRule) {
					name = jsonFieldsNameOfRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Rule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Rule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleAction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleAction) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		s.Value.Encode(e)
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.StopProcessing.Set {
			e.FieldStart("stop_processing")
			s.StopProcessing.Encode(e)
		}
	}
}

var jsonFieldsNameOfRuleAction = [8]string{
	0: "id",
	1: "created_at",
	2: "updated_at",
	3: "type",
	4: "value",
	5: "order",
	6: "active",
	7: "stop_processing",
}

// Decode decodes RuleAction from json.
func (s *RuleAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleAction to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "stop_processing":
			if err := func() error {
				s.StopProcessing.Reset()
				if err := s.StopProcessing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop_processing\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleAction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRuleAction) {
					name = jsonFieldsNameOfRuleAction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleActionKeyword as json.
func (s RuleActionKeyword) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RuleActionKeyword from json.
func (s *RuleActionKeyword) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleActionKeyword to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RuleActionKeyword(v) {
	case RuleActionKeywordUserAction:
		*s = RuleActionKeywordUserAction
	case RuleActionKeywordSetCategory:
		*s = RuleActionKeywordSetCategory
	case RuleActionKeywordClearCategory:
		*s = RuleActionKeywordClearCategory
	case RuleActionKeywordSetBudget:
		*s = RuleActionKeywordSetBudget
	case RuleActionKeywordClearBudget:
		*s = RuleActionKeywordClearBudget
	case RuleActionKeywordAddTag:
		*s = RuleActionKeywordAddTag
	case RuleActionKeywordRemoveTag:
		*s = RuleActionKeywordRemoveTag
	case RuleActionKeywordRemoveAllTags:
		*s = RuleActionKeywordRemoveAllTags
	case RuleActionKeywordSetDescription:
		*s = RuleActionKeywordSetDescription
	case RuleActionKeywordAppendDescription:
		*s = RuleActionKeywordAppendDescription
	case RuleActionKeywordPrependDescription:
		*s = RuleActionKeywordPrependDescription
	case RuleActionKeywordSetSourceAccount:
		*s = RuleActionKeywordSetSourceAccount
	case RuleActionKeywordSetDestinationAccount:
		*s = RuleActionKeywordSetDestinationAccount
	case RuleActionKeywordSetNotes:
		*s = RuleActionKeywordSetNotes
	case RuleActionKeywordAppendNotes:
		*s = RuleActionKeywordAppendNotes
	case RuleActionKeywordPrependNotes:
		*s = RuleActionKeywordPrependNotes
	case RuleActionKeywordClearNotes:
		*s = RuleActionKeywordClearNotes
	case RuleActionKeywordLinkToBill:
		*s = RuleActionKeywordLinkToBill
	case RuleActionKeywordConvertWithdrawal:
		*s = RuleActionKeywordConvertWithdrawal
	case RuleActionKeywordConvertDeposit:
		*s = RuleActionKeywordConvertDeposit
	case RuleActionKeywordConvertTransfer:
		*s = RuleActionKeywordConvertTransfer
	case RuleActionKeywordDeleteTransaction:
		*s = RuleActionKeywordDeleteTransaction
	default:
		*s = RuleActionKeyword(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RuleActionKeyword) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleActionKeyword) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleActionStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleActionStore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		s.Value.Encode(e)
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.StopProcessing.Set {
			e.FieldStart("stop_processing")
			s.StopProcessing.Encode(e)
		}
	}
}

var jsonFieldsNameOfRuleActionStore = [5]string{
	0: "type",
	1: "value",
	2: "order",
	3: "active",
	4: "stop_processing",
}

// Decode decodes RuleActionStore from json.
func (s *RuleActionStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleActionStore to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "stop_processing":
			if err := func() error {
				s.StopProcessing.Reset()
				if err := s.StopProcessing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop_processing\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleActionStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRuleActionStore) {
					name = jsonFieldsNameOfRuleActionStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleActionStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleActionStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleActionUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleActionUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.StopProcessing.Set {
			e.FieldStart("stop_processing")
			s.StopProcessing.Encode(e)
		}
	}
}

var jsonFieldsNameOfRuleActionUpdate = [5]string{
	0: "type",
	1: "value",
	2: "order",
	3: "active",
	4: "stop_processing",
}

// Decode decodes RuleActionUpdate from json.
func (s *RuleActionUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleActionUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "stop_processing":
			if err := func() error {
				s.StopProcessing.Reset()
				if err := s.StopProcessing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop_processing\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleActionUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleActionUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleActionUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfRuleArray = [3]string{
	0: "data",
	1: "meta",
	2: "links",
}

// Decode decodes RuleArray from json.
func (s *RuleArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]RuleRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RuleRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRuleArray) {
					name = jsonFieldsNameOfRuleArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleGroup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleGroup) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
}

var jsonFieldsNameOfRuleGroup = [6]string{
	0: "created_at",
	1: "updated_at",
	2: "title",
	3: "description",
	4: "order",
	5: "active",
}

// Decode decodes RuleGroup from json.
func (s *RuleGroup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleGroup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleGroup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRuleGroup) {
					name = jsonFieldsNameOfRuleGroup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleGroup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleGroup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleGroupArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleGroupArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfRuleGroupArray = [3]string{
	0: "data",
	1: "meta",
	2: "links",
}

// Decode decodes RuleGroupArray from json.
func (s *RuleGroupArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleGroupArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]RuleGroupRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RuleGroupRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleGroupArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRuleGroupArray) {
					name = jsonFieldsNameOfRuleGroupArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleGroupArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleGroupArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleGroupRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleGroupRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfRuleGroupRead = [4]string{
	0: "type",
	1: "id",
	2: "attributes",
	3: "links",
}

// Decode decodes RuleGroupRead from json.
func (s *RuleGroupRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleGroupRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleGroupRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRuleGroupRead) {
					name = jsonFieldsNameOfRuleGroupRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleGroupRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleGroupRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleGroupSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleGroupSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfRuleGroupSingle = [1]string{
	0: "data",
}

// Decode decodes RuleGroupSingle from json.
func (s *RuleGroupSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleGroupSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleGroupSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRuleGroupSingle) {
					name = jsonFieldsNameOfRuleGroupSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleGroupSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleGroupSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleGroupStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleGroupStore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
}

var jsonFieldsNameOfRuleGroupStore = [4]string{
	0: "title",
	1: "description",
	2: "order",
	3: "active",
}

// Decode decodes RuleGroupStore from json.
func (s *RuleGroupStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleGroupStore to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleGroupStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRuleGroupStore) {
					name = jsonFieldsNameOfRuleGroupStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleGroupStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleGroupStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleGroupUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleGroupUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
}

var jsonFieldsNameOfRuleGroupUpdate = [4]string{
	0: "title",
	1: "description",
	2: "order",
	3: "active",
}

// Decode decodes RuleGroupUpdate from json.
func (s *RuleGroupUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleGroupUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleGroupUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleGroupUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleGroupUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfRuleRead = [4]string{
	0: "type",
	1: "id",
	2: "attributes",
	3: "links",
}

// Decode decodes RuleRead from json.
func (s *RuleRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRuleRead) {
					name = jsonFieldsNameOfRuleRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfRuleSingle = [1]string{
	0: "data",
}

// Decode decodes RuleSingle from json.
func (s *RuleSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRuleSingle) {
					name = jsonFieldsNameOfRuleSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleStore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("rule_group_id")
		e.Str(s.RuleGroupID)
	}
	{
		if s.RuleGroupTitle.Set {
			e.FieldStart("rule_group_title")
			s.RuleGroupTitle.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		e.FieldStart("trigger")
		s.Trigger.Encode(e)
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Strict.Set {
			e.FieldStart("strict")
			s.Strict.Encode(e)
		}
	}
	{
		if s.StopProcessing.Set {
			e.FieldStart("stop_processing")
			s.StopProcessing.Encode(e)
		}
	}
	{
		e.FieldStart("triggers")
		e.ArrStart()
		for _, elem := range s.Triggers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("actions")
		e.ArrStart()
		for _, elem := range s.Actions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRuleStore = [11]string{
	0:  "title",
	1:  "description",
	2:  "rule_group_id",
	3:  "rule_group_title",
	4:  "order",
	5:  "trigger",
	6:  "active",
	7:  "strict",
	8:  "stop_processing",
	9:  "triggers",
	10: "actions",
}

// Decode decodes RuleStore from json.
func (s *RuleStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleStore to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "rule_group_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.RuleGroupID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule_group_id\"")
			}
		case "rule_group_title":
			if err := func() error {
				s.RuleGroupTitle.Reset()
				if err := s.RuleGroupTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule_group_title\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "trigger":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Trigger.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trigger\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "strict":
			if err := func() error {
				s.Strict.Reset()
				if err := s.Strict.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strict\"")
			}
		case "stop_processing":
			if err := func() error {
				s.StopProcessing.Reset()
				if err := s.StopProcessing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop_processing\"")
			}
		case "triggers":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				s.Triggers = make([]RuleTriggerStore, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RuleTriggerStore
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Triggers = append(s.Triggers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triggers\"")
			}
		case "actions":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.Actions = make([]RuleActionStore, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RuleActionStore
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Actions = append(s.Actions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00100101,
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRuleStore) {
					name = jsonFieldsNameOfRuleStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleTrigger) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleTrigger) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.StopProcessing.Set {
			e.FieldStart("stop_processing")
			s.StopProcessing.Encode(e)
		}
	}
}

var jsonFieldsNameOfRuleTrigger = [8]string{
	0: "id",
	1: "created_at",
	2: "updated_at",
	3: "type",
	4: "value",
	5: "order",
	6: "active",
	7: "stop_processing",
}

// Decode decodes RuleTrigger from json.
func (s *RuleTrigger) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleTrigger to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "stop_processing":
			if err := func() error {
				s.StopProcessing.Reset()
				if err := s.StopProcessing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop_processing\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleTrigger")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRuleTrigger) {
					name = jsonFieldsNameOfRuleTrigger[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleTrigger) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleTrigger) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleTriggerKeyword as json.
func (s RuleTriggerKeyword) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RuleTriggerKeyword from json.
func (s *RuleTriggerKeyword) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleTriggerKeyword to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RuleTriggerKeyword(v) {
	case RuleTriggerKeywordFromAccountStarts:
		*s = RuleTriggerKeywordFromAccountStarts
	case RuleTriggerKeywordFromAccountEnds:
		*s = RuleTriggerKeywordFromAccountEnds
	case RuleTriggerKeywordFromAccountIs:
		*s = RuleTriggerKeywordFromAccountIs
	case RuleTriggerKeywordFromAccountContains:
		*s = RuleTriggerKeywordFromAccountContains
	case RuleTriggerKeywordToAccountStarts:
		*s = RuleTriggerKeywordToAccountStarts
	case RuleTriggerKeywordToAccountEnds:
		*s = RuleTriggerKeywordToAccountEnds
	case RuleTriggerKeywordToAccountIs:
		*s = RuleTriggerKeywordToAccountIs
	case RuleTriggerKeywordToAccountContains:
		*s = RuleTriggerKeywordToAccountContains
	case RuleTriggerKeywordAmountLess:
		*s = RuleTriggerKeywordAmountLess
	case RuleTriggerKeywordAmountExactly:
		*s = RuleTriggerKeywordAmountExactly
	case RuleTriggerKeywordAmountMore:
		*s = RuleTriggerKeywordAmountMore
	case RuleTriggerKeywordDescriptionStarts:
		*s = RuleTriggerKeywordDescriptionStarts
	case RuleTriggerKeywordDescriptionEnds:
		*s = RuleTriggerKeywordDescriptionEnds
	case RuleTriggerKeywordDescriptionContains:
		*s = RuleTriggerKeywordDescriptionContains
	case RuleTriggerKeywordDescriptionIs:
		*s = RuleTriggerKeywordDescriptionIs
	case RuleTriggerKeywordTransactionType:
		*s = RuleTriggerKeywordTransactionType
	case RuleTriggerKeywordCategoryIs:
		*s = RuleTriggerKeywordCategoryIs
	case RuleTriggerKeywordBudgetIs:
		*s = RuleTriggerKeywordBudgetIs
	case RuleTriggerKeywordTagIs:
		*s = RuleTriggerKeywordTagIs
	case RuleTriggerKeywordCurrencyIs:
		*s = RuleTriggerKeywordCurrencyIs
	case RuleTriggerKeywordHasAttachments:
		*s = RuleTriggerKeywordHasAttachments
	case RuleTriggerKeywordHasNoCategory:
		*s = RuleTriggerKeywordHasNoCategory
	case RuleTriggerKeywordHasAnyCategory:
		*s = RuleTriggerKeywordHasAnyCategory
	case RuleTriggerKeywordHasNoBudget:
		*s = RuleTriggerKeywordHasNoBudget
	case RuleTriggerKeywordHasAnyBudget:
		*s = RuleTriggerKeywordHasAnyBudget
	case RuleTriggerKeywordHasNoTag:
		*s = RuleTriggerKeywordHasNoTag
	case RuleTriggerKeywordHasAnyTag:
		*s = RuleTriggerKeywordHasAnyTag
	case RuleTriggerKeywordNotesContains:
		*s = RuleTriggerKeywordNotesContains
	case RuleTriggerKeywordNotesStart:
		*s = RuleTriggerKeywordNotesStart
	case RuleTriggerKeywordNotesEnd:
		*s = RuleTriggerKeywordNotesEnd
	case RuleTriggerKeywordNotesAre:
		*s = RuleTriggerKeywordNotesAre
	case RuleTriggerKeywordNoNotes:
		*s = RuleTriggerKeywordNoNotes
	case RuleTriggerKeywordAnyNotes:
		*s = RuleTriggerKeywordAnyNotes
	case RuleTriggerKeywordSourceAccountIs:
		*s = RuleTriggerKeywordSourceAccountIs
	case RuleTriggerKeywordDestinationAccountIs:
		*s = RuleTriggerKeywordDestinationAccountIs
	case RuleTriggerKeywordSourceAccountStarts:
		*s = RuleTriggerKeywordSourceAccountStarts
	default:
		*s = RuleTriggerKeyword(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RuleTriggerKeyword) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleTriggerKeyword) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleTriggerStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleTriggerStore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.StopProcessing.Set {
			e.FieldStart("stop_processing")
			s.StopProcessing.Encode(e)
		}
	}
}

var jsonFieldsNameOfRuleTriggerStore = [5]string{
	0: "type",
	1: "value",
	2: "order",
	3: "active",
	4: "stop_processing",
}

// Decode decodes RuleTriggerStore from json.
func (s *RuleTriggerStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleTriggerStore to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "stop_processing":
			if err := func() error {
				s.StopProcessing.Reset()
				if err := s.StopProcessing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop_processing\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleTriggerStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRuleTriggerStore) {
					name = jsonFieldsNameOfRuleTriggerStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleTriggerStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleTriggerStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RuleTriggerType as json.
func (s RuleTriggerType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RuleTriggerType from json.
func (s *RuleTriggerType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleTriggerType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RuleTriggerType(v) {
	case RuleTriggerTypeStoreJournal:
		*s = RuleTriggerTypeStoreJournal
	case RuleTriggerTypeUpdateJournal:
		*s = RuleTriggerTypeUpdateJournal
	default:
		*s = RuleTriggerType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RuleTriggerType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleTriggerType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleTriggerUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleTriggerUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.StopProcessing.Set {
			e.FieldStart("stop_processing")
			s.StopProcessing.Encode(e)
		}
	}
}

var jsonFieldsNameOfRuleTriggerUpdate = [5]string{
	0: "type",
	1: "value",
	2: "order",
	3: "active",
	4: "stop_processing",
}

// Decode decodes RuleTriggerUpdate from json.
func (s *RuleTriggerUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleTriggerUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "stop_processing":
			if err := func() error {
				s.StopProcessing.Reset()
				if err := s.StopProcessing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop_processing\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleTriggerUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleTriggerUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleTriggerUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RuleUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RuleUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.RuleGroupID.Set {
			e.FieldStart("rule_group_id")
			s.RuleGroupID.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.Trigger.Set {
			e.FieldStart("trigger")
			s.Trigger.Encode(e)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Strict.Set {
			e.FieldStart("strict")
			s.Strict.Encode(e)
		}
	}
	{
		if s.StopProcessing.Set {
			e.FieldStart("stop_processing")
			s.StopProcessing.Encode(e)
		}
	}
	{
		if s.Triggers != nil {
			e.FieldStart("triggers")
			e.ArrStart()
			for _, elem := range s.Triggers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Actions != nil {
			e.FieldStart("actions")
			e.ArrStart()
			for _, elem := range s.Actions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRuleUpdate = [10]string{
	0: "title",
	1: "description",
	2: "rule_group_id",
	3: "order",
	4: "trigger",
	5: "active",
	6: "strict",
	7: "stop_processing",
	8: "triggers",
	9: "actions",
}

// Decode decodes RuleUpdate from json.
func (s *RuleUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RuleUpdate to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "rule_group_id":
			if err := func() error {
				s.RuleGroupID.Reset()
				if err := s.RuleGroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule_group_id\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "trigger":
			if err := func() error {
				s.Trigger.Reset()
				if err := s.Trigger.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trigger\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "strict":
			if err := func() error {
				s.Strict.Reset()
				if err := s.Strict.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strict\"")
			}
		case "stop_processing":
			if err := func() error {
				s.StopProcessing.Reset()
				if err := s.StopProcessing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stop_processing\"")
			}
		case "triggers":
			if err := func() error {
				s.Triggers = make([]RuleTriggerUpdate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RuleTriggerUpdate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Triggers = append(s.Triggers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"triggers\"")
			}
		case "actions":
			if err := func() error {
				s.Actions = make([]RuleActionUpdate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RuleActionUpdate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Actions = append(s.Actions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RuleUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RuleUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RuleUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ShortAccountTypeProperty as json.
func (s ShortAccountTypeProperty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ShortAccountTypeProperty from json.
func (s *ShortAccountTypeProperty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ShortAccountTypeProperty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ShortAccountTypeProperty(v) {
	case ShortAccountTypePropertyAsset:
		*s = ShortAccountTypePropertyAsset
	case ShortAccountTypePropertyExpense:
		*s = ShortAccountTypePropertyExpense
	case ShortAccountTypePropertyImport:
		*s = ShortAccountTypePropertyImport
	case ShortAccountTypePropertyRevenue:
		*s = ShortAccountTypePropertyRevenue
	case ShortAccountTypePropertyCash:
		*s = ShortAccountTypePropertyCash
	case ShortAccountTypePropertyLiability:
		*s = ShortAccountTypePropertyLiability
	case ShortAccountTypePropertyLiabilities:
		*s = ShortAccountTypePropertyLiabilities
	case ShortAccountTypePropertyInitialBalance:
		*s = ShortAccountTypePropertyInitialBalance
	case ShortAccountTypePropertyReconciliation:
		*s = ShortAccountTypePropertyReconciliation
	default:
		*s = ShortAccountTypeProperty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ShortAccountTypeProperty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ShortAccountTypeProperty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StringArrayItem as json.
func (s StringArrayItem) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes StringArrayItem from json.
func (s *StringArrayItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StringArrayItem to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = StringArrayItem(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StringArrayItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StringArrayItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSystemInfo = [1]string{
	0: "data",
}

// Decode decodes SystemInfo from json.
func (s *SystemInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemInfoData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemInfoData) encodeFields(e *jx.Encoder) {
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.APIVersion.Set {
			e.FieldStart("api_version")
			s.APIVersion.Encode(e)
		}
	}
	{
		if s.PhpVersion.Set {
			e.FieldStart("php_version")
			s.PhpVersion.Encode(e)
		}
	}
	{
		if s.Os.Set {
			e.FieldStart("os")
			s.Os.Encode(e)
		}
	}
	{
		if s.Driver.Set {
			e.FieldStart("driver")
			s.Driver.Encode(e)
		}
	}
}

var jsonFieldsNameOfSystemInfoData = [5]string{
	0: "version",
	1: "api_version",
	2: "php_version",
	3: "os",
	4: "driver",
}

// Decode decodes SystemInfoData from json.
func (s *SystemInfoData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemInfoData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "api_version":
			if err := func() error {
				s.APIVersion.Reset()
				if err := s.APIVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_version\"")
			}
		case "php_version":
			if err := func() error {
				s.PhpVersion.Reset()
				if err := s.PhpVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"php_version\"")
			}
		case "os":
			if err := func() error {
				s.Os.Reset()
				if err := s.Os.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"os\"")
			}
		case "driver":
			if err := func() error {
				s.Driver.Reset()
				if err := s.Driver.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"driver\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemInfoData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemInfoData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemInfoData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfTagArray = [3]string{
	0: "data",
	1: "meta",
	2: "links",
}

// Decode decodes TagArray from json.
func (s *TagArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]TagRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TagRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagArray) {
					name = jsonFieldsNameOfTagArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagModel) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Latitude.Set {
			e.FieldStart("latitude")
			s.Latitude.Encode(e)
		}
	}
	{
		if s.Longitude.Set {
			e.FieldStart("longitude")
			s.Longitude.Encode(e)
		}
	}
	{
		if s.ZoomLevel.Set {
			e.FieldStart("zoom_level")
			s.ZoomLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfTagModel = [8]string{
	0: "created_at",
	1: "updated_at",
	2: "tag",
	3: "date",
	4: "description",
	5: "latitude",
	6: "longitude",
	7: "zoom_level",
}

// Decode decodes TagModel from json.
func (s *TagModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "latitude":
			if err := func() error {
				s.Latitude.Reset()
				if err := s.Latitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			if err := func() error {
				s.Longitude.Reset()
				if err := s.Longitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "zoom_level":
			if err := func() error {
				s.ZoomLevel.Reset()
				if err := s.ZoomLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zoom_level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagModel) {
					name = jsonFieldsNameOfTagModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagModelStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagModelStore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Latitude.Set {
			e.FieldStart("latitude")
			s.Latitude.Encode(e)
		}
	}
	{
		if s.Longitude.Set {
			e.FieldStart("longitude")
			s.Longitude.Encode(e)
		}
	}
	{
		if s.ZoomLevel.Set {
			e.FieldStart("zoom_level")
			s.ZoomLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfTagModelStore = [6]string{
	0: "tag",
	1: "date",
	2: "description",
	3: "latitude",
	4: "longitude",
	5: "zoom_level",
}

// Decode decodes TagModelStore from json.
func (s *TagModelStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagModelStore to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "latitude":
			if err := func() error {
				s.Latitude.Reset()
				if err := s.Latitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			if err := func() error {
				s.Longitude.Reset()
				if err := s.Longitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "zoom_level":
			if err := func() error {
				s.ZoomLevel.Reset()
				if err := s.ZoomLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zoom_level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagModelStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagModelStore) {
					name = jsonFieldsNameOfTagModelStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagModelStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagModelStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagModelUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagModelUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Latitude.Set {
			e.FieldStart("latitude")
			s.Latitude.Encode(e)
		}
	}
	{
		if s.Longitude.Set {
			e.FieldStart("longitude")
			s.Longitude.Encode(e)
		}
	}
	{
		if s.ZoomLevel.Set {
			e.FieldStart("zoom_level")
			s.ZoomLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfTagModelUpdate = [6]string{
	0: "tag",
	1: "date",
	2: "description",
	3: "latitude",
	4: "longitude",
	5: "zoom_level",
}

// Decode decodes TagModelUpdate from json.
func (s *TagModelUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagModelUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "latitude":
			if err := func() error {
				s.Latitude.Reset()
				if err := s.Latitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			if err := func() error {
				s.Longitude.Reset()
				if err := s.Longitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "zoom_level":
			if err := func() error {
				s.ZoomLevel.Reset()
				if err := s.ZoomLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zoom_level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagModelUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagModelUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagModelUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfTagRead = [4]string{
	0: "type",
	1: "id",
	2: "attributes",
	3: "links",
}

// Decode decodes TagRead from json.
func (s *TagRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagRead) {
					name = jsonFieldsNameOfTagRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TagSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TagSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfTagSingle = [1]string{
	0: "data",
}

// Decode decodes TagSingle from json.
func (s *TagSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TagSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TagSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTagSingle) {
					name = jsonFieldsNameOfTagSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TagSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TagSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Transaction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Transaction) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.GroupTitle.Set {
			e.FieldStart("group_title")
			s.GroupTitle.Encode(e)
		}
	}
	{
		e.FieldStart("transactions")
		e.ArrStart()
		for _, elem := range s.Transactions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTransaction = [5]string{
	0: "created_at",
	1: "updated_at",
	2: "user",
	3: "group_title",
	4: "transactions",
}

// Decode decodes Transaction from json.
func (s *Transaction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Transaction to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "group_title":
			if err := func() error {
				s.GroupTitle.Reset()
				if err := s.GroupTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_title\"")
			}
		case "transactions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Transactions = make([]TransactionSplit, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TransactionSplit
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Transactions = append(s.Transactions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Transaction")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransaction) {
					name = jsonFieldsNameOfTransaction[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Transaction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Transaction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransactionArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransactionArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfTransactionArray = [3]string{
	0: "data",
	1: "meta",
	2: "links",
}

// Decode decodes TransactionArray from json.
func (s *TransactionArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]TransactionRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TransactionRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransactionArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransactionArray) {
					name = jsonFieldsNameOfTransactionArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransactionArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransactionLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransactionLink) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("link_type_id")
		e.Str(s.LinkTypeID)
	}
	{
		if s.LinkTypeName.Set {
			e.FieldStart("link_type_name")
			s.LinkTypeName.Encode(e)
		}
	}
	{
		e.FieldStart("inward_id")
		e.Str(s.InwardID)
	}
	{
		e.FieldStart("outward_id")
		e.Str(s.OutwardID)
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
}

var jsonFieldsNameOfTransactionLink = [7]string{
	0: "created_at",
	1: "updated_at",
	2: "link_type_id",
	3: "link_type_name",
	4: "inward_id",
	5: "outward_id",
	6: "notes",
}

// Decode decodes TransactionLink from json.
func (s *TransactionLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionLink to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "link_type_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.LinkTypeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_type_id\"")
			}
		case "link_type_name":
			if err := func() error {
				s.LinkTypeName.Reset()
				if err := s.LinkTypeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_type_name\"")
			}
		case "inward_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.InwardID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inward_id\"")
			}
		case "outward_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.OutwardID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outward_id\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransactionLink")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransactionLink) {
					name = jsonFieldsNameOfTransactionLink[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransactionLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransactionLinkArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransactionLinkArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfTransactionLinkArray = [3]string{
	0: "data",
	1: "meta",
	2: "links",
}

// Decode decodes TransactionLinkArray from json.
func (s *TransactionLinkArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionLinkArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]TransactionLinkRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TransactionLinkRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransactionLinkArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransactionLinkArray) {
					name = jsonFieldsNameOfTransactionLinkArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransactionLinkArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionLinkArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransactionLinkRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransactionLinkRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfTransactionLinkRead = [4]string{
	0: "type",
	1: "id",
	2: "attributes",
	3: "links",
}

// Decode decodes TransactionLinkRead from json.
func (s *TransactionLinkRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionLinkRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransactionLinkRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransactionLinkRead) {
					name = jsonFieldsNameOfTransactionLinkRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransactionLinkRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionLinkRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransactionLinkSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransactionLinkSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfTransactionLinkSingle = [1]string{
	0: "data",
}

// Decode decodes TransactionLinkSingle from json.
func (s *TransactionLinkSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionLinkSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransactionLinkSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransactionLinkSingle) {
					name = jsonFieldsNameOfTransactionLinkSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransactionLinkSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionLinkSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransactionLinkStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransactionLinkStore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("link_type_id")
		e.Str(s.LinkTypeID)
	}
	{
		if s.LinkTypeName.Set {
			e.FieldStart("link_type_name")
			s.LinkTypeName.Encode(e)
		}
	}
	{
		e.FieldStart("inward_id")
		e.Str(s.InwardID)
	}
	{
		e.FieldStart("outward_id")
		e.Str(s.OutwardID)
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
}

var jsonFieldsNameOfTransactionLinkStore = [5]string{
	0: "link_type_id",
	1: "link_type_name",
	2: "inward_id",
	3: "outward_id",
	4: "notes",
}

// Decode decodes TransactionLinkStore from json.
func (s *TransactionLinkStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionLinkStore to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "link_type_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.LinkTypeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_type_id\"")
			}
		case "link_type_name":
			if err := func() error {
				s.LinkTypeName.Reset()
				if err := s.LinkTypeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_type_name\"")
			}
		case "inward_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.InwardID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inward_id\"")
			}
		case "outward_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.OutwardID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outward_id\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransactionLinkStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransactionLinkStore) {
					name = jsonFieldsNameOfTransactionLinkStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransactionLinkStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionLinkStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransactionLinkUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransactionLinkUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.LinkTypeID.Set {
			e.FieldStart("link_type_id")
			s.LinkTypeID.Encode(e)
		}
	}
	{
		if s.LinkTypeName.Set {
			e.FieldStart("link_type_name")
			s.LinkTypeName.Encode(e)
		}
	}
	{
		if s.InwardID.Set {
			e.FieldStart("inward_id")
			s.InwardID.Encode(e)
		}
	}
	{
		if s.OutwardID.Set {
			e.FieldStart("outward_id")
			s.OutwardID.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
}

var jsonFieldsNameOfTransactionLinkUpdate = [5]string{
	0: "link_type_id",
	1: "link_type_name",
	2: "inward_id",
	3: "outward_id",
	4: "notes",
}

// Decode decodes TransactionLinkUpdate from json.
func (s *TransactionLinkUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionLinkUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "link_type_id":
			if err := func() error {
				s.LinkTypeID.Reset()
				if err := s.LinkTypeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_type_id\"")
			}
		case "link_type_name":
			if err := func() error {
				s.LinkTypeName.Reset()
				if err := s.LinkTypeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_type_name\"")
			}
		case "inward_id":
			if err := func() error {
				s.InwardID.Reset()
				if err := s.InwardID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inward_id\"")
			}
		case "outward_id":
			if err := func() error {
				s.OutwardID.Reset()
				if err := s.OutwardID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outward_id\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransactionLinkUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransactionLinkUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionLinkUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransactionRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransactionRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfTransactionRead = [4]string{
	0: "type",
	1: "id",
	2: "attributes",
	3: "links",
}

// Decode decodes TransactionRead from json.
func (s *TransactionRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransactionRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransactionRead) {
					name = jsonFieldsNameOfTransactionRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransactionRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransactionSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransactionSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfTransactionSingle = [1]string{
	0: "data",
}

// Decode decodes TransactionSingle from json.
func (s *TransactionSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransactionSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransactionSingle) {
					name = jsonFieldsNameOfTransactionSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransactionSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransactionSplit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransactionSplit) encodeFields(e *jx.Encoder) {
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.TransactionJournalID.Set {
			e.FieldStart("transaction_journal_id")
			s.TransactionJournalID.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("date")
		json.EncodeDateTime(e, s.Date)
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.CurrencySymbol.Set {
			e.FieldStart("currency_symbol")
			s.CurrencySymbol.Encode(e)
		}
	}
	{
		if s.CurrencyName.Set {
			e.FieldStart("currency_name")
			s.CurrencyName.Encode(e)
		}
	}
	{
		if s.CurrencyDecimalPlaces.Set {
			e.FieldStart("currency_decimal_places")
			s.CurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		if s.ForeignCurrencyID.Set {
			e.FieldStart("foreign_currency_id")
			s.ForeignCurrencyID.Encode(e)
		}
	}
	{
		if s.ForeignCurrencyCode.Set {
			e.FieldStart("foreign_currency_code")
			s.ForeignCurrencyCode.Encode(e)
		}
	}
	{
		if s.ForeignCurrencySymbol.Set {
			e.FieldStart("foreign_currency_symbol")
			s.ForeignCurrencySymbol.Encode(e)
		}
	}
	{
		if s.ForeignCurrencyDecimalPlaces.Set {
			e.FieldStart("foreign_currency_decimal_places")
			s.ForeignCurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		e.FieldStart("amount")
		e.Str(s.Amount)
	}
	{
		if s.ForeignAmount.Set {
			e.FieldStart("foreign_amount")
			s.ForeignAmount.Encode(e)
		}
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("source_id")
		s.SourceID.Encode(e)
	}
	{
		if s.SourceName.Set {
			e.FieldStart("source_name")
			s.SourceName.Encode(e)
		}
	}
	{
		if s.SourceIban.Set {
			e.FieldStart("source_iban")
			s.SourceIban.Encode(e)
		}
	}
	{
		if s.SourceType.Set {
			e.FieldStart("source_type")
			s.SourceType.Encode(e)
		}
	}
	{
		e.FieldStart("destination_id")
		s.DestinationID.Encode(e)
	}
	{
		if s.DestinationName.Set {
			e.FieldStart("destination_name")
			s.DestinationName.Encode(e)
		}
	}
	{
		if s.DestinationIban.Set {
			e.FieldStart("destination_iban")
			s.DestinationIban.Encode(e)
		}
	}
	{
		if s.DestinationType.Set {
			e.FieldStart("destination_type")
			s.DestinationType.Encode(e)
		}
	}
	{
		if s.BudgetID.Set {
			e.FieldStart("budget_id")
			s.BudgetID.Encode(e)
		}
	}
	{
		if s.BudgetName.Set {
			e.FieldStart("budget_name")
			s.BudgetName.Encode(e)
		}
	}
	{
		if s.CategoryID.Set {
			e.FieldStart("category_id")
			s.CategoryID.Encode(e)
		}
	}
	{
		if s.CategoryName.Set {
			e.FieldStart("category_name")
			s.CategoryName.Encode(e)
		}
	}
	{
		if s.BillID.Set {
			e.FieldStart("bill_id")
			s.BillID.Encode(e)
		}
	}
	{
		if s.BillName.Set {
			e.FieldStart("bill_name")
			s.BillName.Encode(e)
		}
	}
	{
		if s.Reconciled.Set {
			e.FieldStart("reconciled")
			s.Reconciled.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.InternalReference.Set {
			e.FieldStart("internal_reference")
			s.InternalReference.Encode(e)
		}
	}
	{
		if s.ExternalID.Set {
			e.FieldStart("external_id")
			s.ExternalID.Encode(e)
		}
	}
	{
		if s.ExternalURL.Set {
			e.FieldStart("external_url")
			s.ExternalURL.Encode(e)
		}
	}
	{
		if s.OriginalSource.Set {
			e.FieldStart("original_source")
			s.OriginalSource.Encode(e)
		}
	}
	{
		if s.RecurrenceID.Set {
			e.FieldStart("recurrence_id")
			s.RecurrenceID.Encode(e)
		}
	}
	{
		if s.RecurrenceTotal.Set {
			e.FieldStart("recurrence_total")
			s.RecurrenceTotal.Encode(e)
		}
	}
	{
		if s.RecurrenceCount.Set {
			e.FieldStart("recurrence_count")
			s.RecurrenceCount.Encode(e)
		}
	}
	{
		if s.BunqPaymentID.Set {
			e.FieldStart("bunq_payment_id")
			s.BunqPaymentID.Encode(e)
		}
	}
	{
		if s.ImportHashV2.Set {
			e.FieldStart("import_hash_v2")
			s.ImportHashV2.Encode(e)
		}
	}
	{
		if s.SepaCc.Set {
			e.FieldStart("sepa_cc")
			s.SepaCc.Encode(e)
		}
	}
	{
		if s.SepaCtOp.Set {
			e.FieldStart("sepa_ct_op")
			s.SepaCtOp.Encode(e)
		}
	}
	{
		if s.SepaCtID.Set {
			e.FieldStart("sepa_ct_id")
			s.SepaCtID.Encode(e)
		}
	}
	{
		if s.SepaDb.Set {
			e.FieldStart("sepa_db")
			s.SepaDb.Encode(e)
		}
	}
	{
		if s.SepaCountry.Set {
			e.FieldStart("sepa_country")
			s.SepaCountry.Encode(e)
		}
	}
	{
		if s.SepaEp.Set {
			e.FieldStart("sepa_ep")
			s.SepaEp.Encode(e)
		}
	}
	{
		if s.SepaCi.Set {
			e.FieldStart("sepa_ci")
			s.SepaCi.Encode(e)
		}
	}
	{
		if s.SepaBatchID.Set {
			e.FieldStart("sepa_batch_id")
			s.SepaBatchID.Encode(e)
		}
	}
	{
		if s.InterestDate.Set {
			e.FieldStart("interest_date")
			s.InterestDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.BookDate.Set {
			e.FieldStart("book_date")
			s.BookDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ProcessDate.Set {
			e.FieldStart("process_date")
			s.ProcessDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DueDate.Set {
			e.FieldStart("due_date")
			s.DueDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PaymentDate.Set {
			e.FieldStart("payment_date")
			s.PaymentDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InvoiceDate.Set {
			e.FieldStart("invoice_date")
			s.InvoiceDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Latitude.Set {
			e.FieldStart("latitude")
			s.Latitude.Encode(e)
		}
	}
	{
		if s.Longitude.Set {
			e.FieldStart("longitude")
			s.Longitude.Encode(e)
		}
	}
	{
		if s.ZoomLevel.Set {
			e.FieldStart("zoom_level")
			s.ZoomLevel.Encode(e)
		}
	}
	{
		if s.HasAttachments.Set {
			e.FieldStart("has_attachments")
			s.HasAttachments.Encode(e)
		}
	}
}

var jsonFieldsNameOfTransactionSplit = [61]string{
	0:  "user",
	1:  "transaction_journal_id",
	2:  "type",
	3:  "date",
	4:  "order",
	5:  "currency_id",
	6:  "currency_code",
	7:  "currency_symbol",
	8:  "currency_name",
	9:  "currency_decimal_places",
	10: "foreign_currency_id",
	11: "foreign_currency_code",
	12: "foreign_currency_symbol",
	13: "foreign_currency_decimal_places",
	14: "amount",
	15: "foreign_amount",
	16: "description",
	17: "source_id",
	18: "source_name",
	19: "source_iban",
	20: "source_type",
	21: "destination_id",
	22: "destination_name",
	23: "destination_iban",
	24: "destination_type",
	25: "budget_id",
	26: "budget_name",
	27: "category_id",
	28: "category_name",
	29: "bill_id",
	30: "bill_name",
	31: "reconciled",
	32: "notes",
	33: "tags",
	34: "internal_reference",
	35: "external_id",
	36: "external_url",
	37: "original_source",
	38: "recurrence_id",
	39: "recurrence_total",
	40: "recurrence_count",
	41: "bunq_payment_id",
	42: "import_hash_v2",
	43: "sepa_cc",
	44: "sepa_ct_op",
	45: "sepa_ct_id",
	46: "sepa_db",
	47: "sepa_country",
	48: "sepa_ep",
	49: "sepa_ci",
	50: "sepa_batch_id",
	51: "interest_date",
	52: "book_date",
	53: "process_date",
	54: "due_date",
	55: "payment_date",
	56: "invoice_date",
	57: "latitude",
	58: "longitude",
	59: "zoom_level",
	60: "has_attachments",
}

// Decode decodes TransactionSplit from json.
func (s *TransactionSplit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionSplit to nil")
	}
	var requiredBitSet [8]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "transaction_journal_id":
			if err := func() error {
				s.TransactionJournalID.Reset()
				if err := s.TransactionJournalID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transaction_journal_id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Date = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "currency_symbol":
			if err := func() error {
				s.CurrencySymbol.Reset()
				if err := s.CurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_symbol\"")
			}
		case "currency_name":
			if err := func() error {
				s.CurrencyName.Reset()
				if err := s.CurrencyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_name\"")
			}
		case "currency_decimal_places":
			if err := func() error {
				s.CurrencyDecimalPlaces.Reset()
				if err := s.CurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_decimal_places\"")
			}
		case "foreign_currency_id":
			if err := func() error {
				s.ForeignCurrencyID.Reset()
				if err := s.ForeignCurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_currency_id\"")
			}
		case "foreign_currency_code":
			if err := func() error {
				s.ForeignCurrencyCode.Reset()
				if err := s.ForeignCurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_currency_code\"")
			}
		case "foreign_currency_symbol":
			if err := func() error {
				s.ForeignCurrencySymbol.Reset()
				if err := s.ForeignCurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_currency_symbol\"")
			}
		case "foreign_currency_decimal_places":
			if err := func() error {
				s.ForeignCurrencyDecimalPlaces.Reset()
				if err := s.ForeignCurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_currency_decimal_places\"")
			}
		case "amount":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Amount = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "foreign_amount":
			if err := func() error {
				s.ForeignAmount.Reset()
				if err := s.ForeignAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_amount\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "source_id":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.SourceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_id\"")
			}
		case "source_name":
			if err := func() error {
				s.SourceName.Reset()
				if err := s.SourceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_name\"")
			}
		case "source_iban":
			if err := func() error {
				s.SourceIban.Reset()
				if err := s.SourceIban.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_iban\"")
			}
		case "source_type":
			if err := func() error {
				s.SourceType.Reset()
				if err := s.SourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_type\"")
			}
		case "destination_id":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.DestinationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination_id\"")
			}
		case "destination_name":
			if err := func() error {
				s.DestinationName.Reset()
				if err := s.DestinationName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination_name\"")
			}
		case "destination_iban":
			if err := func() error {
				s.DestinationIban.Reset()
				if err := s.DestinationIban.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination_iban\"")
			}
		case "destination_type":
			if err := func() error {
				s.DestinationType.Reset()
				if err := s.DestinationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination_type\"")
			}
		case "budget_id":
			if err := func() error {
				s.BudgetID.Reset()
				if err := s.BudgetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"budget_id\"")
			}
		case "budget_name":
			if err := func() error {
				s.BudgetName.Reset()
				if err := s.BudgetName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"budget_name\"")
			}
		case "category_id":
			if err := func() error {
				s.CategoryID.Reset()
				if err := s.CategoryID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_id\"")
			}
		case "category_name":
			if err := func() error {
				s.CategoryName.Reset()
				if err := s.CategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_name\"")
			}
		case "bill_id":
			if err := func() error {
				s.BillID.Reset()
				if err := s.BillID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bill_id\"")
			}
		case "bill_name":
			if err := func() error {
				s.BillName.Reset()
				if err := s.BillName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bill_name\"")
			}
		case "reconciled":
			if err := func() error {
				s.Reconciled.Reset()
				if err := s.Reconciled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reconciled\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "internal_reference":
			if err := func() error {
				s.InternalReference.Reset()
				if err := s.InternalReference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internal_reference\"")
			}
		case "external_id":
			if err := func() error {
				s.ExternalID.Reset()
				if err := s.ExternalID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_id\"")
			}
		case "external_url":
			if err := func() error {
				s.ExternalURL.Reset()
				if err := s.ExternalURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_url\"")
			}
		case "original_source":
			if err := func() error {
				s.OriginalSource.Reset()
				if err := s.OriginalSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_source\"")
			}
		case "recurrence_id":
			if err := func() error {
				s.RecurrenceID.Reset()
				if err := s.RecurrenceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recurrence_id\"")
			}
		case "recurrence_total":
			if err := func() error {
				s.RecurrenceTotal.Reset()
				if err := s.RecurrenceTotal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recurrence_total\"")
			}
		case "recurrence_count":
			if err := func() error {
				s.RecurrenceCount.Reset()
				if err := s.RecurrenceCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recurrence_count\"")
			}
		case "bunq_payment_id":
			if err := func() error {
				s.BunqPaymentID.Reset()
				if err := s.BunqPaymentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bunq_payment_id\"")
			}
		case "import_hash_v2":
			if err := func() error {
				s.ImportHashV2.Reset()
				if err := s.ImportHashV2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"import_hash_v2\"")
			}
		case "sepa_cc":
			if err := func() error {
				s.SepaCc.Reset()
				if err := s.SepaCc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_cc\"")
			}
		case "sepa_ct_op":
			if err := func() error {
				s.SepaCtOp.Reset()
				if err := s.SepaCtOp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_ct_op\"")
			}
		case "sepa_ct_id":
			if err := func() error {
				s.SepaCtID.Reset()
				if err := s.SepaCtID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_ct_id\"")
			}
		case "sepa_db":
			if err := func() error {
				s.SepaDb.Reset()
				if err := s.SepaDb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_db\"")
			}
		case "sepa_country":
			if err := func() error {
				s.SepaCountry.Reset()
				if err := s.SepaCountry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_country\"")
			}
		case "sepa_ep":
			if err := func() error {
				s.SepaEp.Reset()
				if err := s.SepaEp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_ep\"")
			}
		case "sepa_ci":
			if err := func() error {
				s.SepaCi.Reset()
				if err := s.SepaCi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_ci\"")
			}
		case "sepa_batch_id":
			if err := func() error {
				s.SepaBatchID.Reset()
				if err := s.SepaBatchID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_batch_id\"")
			}
		case "interest_date":
			if err := func() error {
				s.InterestDate.Reset()
				if err := s.InterestDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interest_date\"")
			}
		case "book_date":
			if err := func() error {
				s.BookDate.Reset()
				if err := s.BookDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"book_date\"")
			}
		case "process_date":
			if err := func() error {
				s.ProcessDate.Reset()
				if err := s.ProcessDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"process_date\"")
			}
		case "due_date":
			if err := func() error {
				s.DueDate.Reset()
				if err := s.DueDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"due_date\"")
			}
		case "payment_date":
			if err := func() error {
				s.PaymentDate.Reset()
				if err := s.PaymentDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payment_date\"")
			}
		case "invoice_date":
			if err := func() error {
				s.InvoiceDate.Reset()
				if err := s.InvoiceDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoice_date\"")
			}
		case "latitude":
			if err := func() error {
				s.Latitude.Reset()
				if err := s.Latitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latitude\"")
			}
		case "longitude":
			if err := func() error {
				s.Longitude.Reset()
				if err := s.Longitude.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"longitude\"")
			}
		case "zoom_level":
			if err := func() error {
				s.ZoomLevel.Reset()
				if err := s.ZoomLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zoom_level\"")
			}
		case "has_attachments":
			if err := func() error {
				s.HasAttachments.Reset()
				if err := s.HasAttachments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_attachments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransactionSplit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [8]uint8{
		0b00001100,
		0b01000000,
		0b00100011,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransactionSplit) {
					name = jsonFieldsNameOfTransactionSplit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransactionSplit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionSplit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransactionSplitStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransactionSplitStore) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("date")
		json.EncodeDateTime(e, s.Date)
	}
	{
		e.FieldStart("amount")
		e.Str(s.Amount)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.ForeignAmount.Set {
			e.FieldStart("foreign_amount")
			s.ForeignAmount.Encode(e)
		}
	}
	{
		if s.ForeignCurrencyID.Set {
			e.FieldStart("foreign_currency_id")
			s.ForeignCurrencyID.Encode(e)
		}
	}
	{
		if s.ForeignCurrencyCode.Set {
			e.FieldStart("foreign_currency_code")
			s.ForeignCurrencyCode.Encode(e)
		}
	}
	{
		if s.BudgetID.Set {
			e.FieldStart("budget_id")
			s.BudgetID.Encode(e)
		}
	}
	{
		if s.BudgetName.Set {
			e.FieldStart("budget_name")
			s.BudgetName.Encode(e)
		}
	}
	{
		if s.CategoryID.Set {
			e.FieldStart("category_id")
			s.CategoryID.Encode(e)
		}
	}
	{
		if s.CategoryName.Set {
			e.FieldStart("category_name")
			s.CategoryName.Encode(e)
		}
	}
	{
		if s.SourceID.Set {
			e.FieldStart("source_id")
			s.SourceID.Encode(e)
		}
	}
	{
		if s.SourceName.Set {
			e.FieldStart("source_name")
			s.SourceName.Encode(e)
		}
	}
	{
		if s.DestinationID.Set {
			e.FieldStart("destination_id")
			s.DestinationID.Encode(e)
		}
	}
	{
		if s.DestinationName.Set {
			e.FieldStart("destination_name")
			s.DestinationName.Encode(e)
		}
	}
	{
		if s.Reconciled.Set {
			e.FieldStart("reconciled")
			s.Reconciled.Encode(e)
		}
	}
	{
		if s.PiggyBankID.Set {
			e.FieldStart("piggy_bank_id")
			s.PiggyBankID.Encode(e)
		}
	}
	{
		if s.PiggyBankName.Set {
			e.FieldStart("piggy_bank_name")
			s.PiggyBankName.Encode(e)
		}
	}
	{
		if s.BillID.Set {
			e.FieldStart("bill_id")
			s.BillID.Encode(e)
		}
	}
	{
		if s.BillName.Set {
			e.FieldStart("bill_name")
			s.BillName.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.InternalReference.Set {
			e.FieldStart("internal_reference")
			s.InternalReference.Encode(e)
		}
	}
	{
		if s.ExternalID.Set {
			e.FieldStart("external_id")
			s.ExternalID.Encode(e)
		}
	}
	{
		if s.ExternalURL.Set {
			e.FieldStart("external_url")
			s.ExternalURL.Encode(e)
		}
	}
	{
		if s.BunqPaymentID.Set {
			e.FieldStart("bunq_payment_id")
			s.BunqPaymentID.Encode(e)
		}
	}
	{
		if s.SepaCc.Set {
			e.FieldStart("sepa_cc")
			s.SepaCc.Encode(e)
		}
	}
	{
		if s.SepaCtOp.Set {
			e.FieldStart("sepa_ct_op")
			s.SepaCtOp.Encode(e)
		}
	}
	{
		if s.SepaCtID.Set {
			e.FieldStart("sepa_ct_id")
			s.SepaCtID.Encode(e)
		}
	}
	{
		if s.SepaDb.Set {
			e.FieldStart("sepa_db")
			s.SepaDb.Encode(e)
		}
	}
	{
		if s.SepaCountry.Set {
			e.FieldStart("sepa_country")
			s.SepaCountry.Encode(e)
		}
	}
	{
		if s.SepaEp.Set {
			e.FieldStart("sepa_ep")
			s.SepaEp.Encode(e)
		}
	}
	{
		if s.SepaCi.Set {
			e.FieldStart("sepa_ci")
			s.SepaCi.Encode(e)
		}
	}
	{
		if s.SepaBatchID.Set {
			e.FieldStart("sepa_batch_id")
			s.SepaBatchID.Encode(e)
		}
	}
	{
		if s.InterestDate.Set {
			e.FieldStart("interest_date")
			s.InterestDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.BookDate.Set {
			e.FieldStart("book_date")
			s.BookDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ProcessDate.Set {
			e.FieldStart("process_date")
			s.ProcessDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DueDate.Set {
			e.FieldStart("due_date")
			s.DueDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PaymentDate.Set {
			e.FieldStart("payment_date")
			s.PaymentDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InvoiceDate.Set {
			e.FieldStart("invoice_date")
			s.InvoiceDate.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfTransactionSplitStore = [43]string{
	0:  "type",
	1:  "date",
	2:  "amount",
	3:  "description",
	4:  "order",
	5:  "currency_id",
	6:  "currency_code",
	7:  "foreign_amount",
	8:  "foreign_currency_id",
	9:  "foreign_currency_code",
	10: "budget_id",
	11: "budget_name",
	12: "category_id",
	13: "category_name",
	14: "source_id",
	15: "source_name",
	16: "destination_id",
	17: "destination_name",
	18: "reconciled",
	19: "piggy_bank_id",
	20: "piggy_bank_name",
	21: "bill_id",
	22: "bill_name",
	23: "tags",
	24: "notes",
	25: "internal_reference",
	26: "external_id",
	27: "external_url",
	28: "bunq_payment_id",
	29: "sepa_cc",
	30: "sepa_ct_op",
	31: "sepa_ct_id",
	32: "sepa_db",
	33: "sepa_country",
	34: "sepa_ep",
	35: "sepa_ci",
	36: "sepa_batch_id",
	37: "interest_date",
	38: "book_date",
	39: "process_date",
	40: "due_date",
	41: "payment_date",
	42: "invoice_date",
}

// Decode decodes TransactionSplitStore from json.
func (s *TransactionSplitStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionSplitStore to nil")
	}
	var requiredBitSet [6]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Date = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Amount = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "foreign_amount":
			if err := func() error {
				s.ForeignAmount.Reset()
				if err := s.ForeignAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_amount\"")
			}
		case "foreign_currency_id":
			if err := func() error {
				s.ForeignCurrencyID.Reset()
				if err := s.ForeignCurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_currency_id\"")
			}
		case "foreign_currency_code":
			if err := func() error {
				s.ForeignCurrencyCode.Reset()
				if err := s.ForeignCurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_currency_code\"")
			}
		case "budget_id":
			if err := func() error {
				s.BudgetID.Reset()
				if err := s.BudgetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"budget_id\"")
			}
		case "budget_name":
			if err := func() error {
				s.BudgetName.Reset()
				if err := s.BudgetName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"budget_name\"")
			}
		case "category_id":
			if err := func() error {
				s.CategoryID.Reset()
				if err := s.CategoryID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_id\"")
			}
		case "category_name":
			if err := func() error {
				s.CategoryName.Reset()
				if err := s.CategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_name\"")
			}
		case "source_id":
			if err := func() error {
				s.SourceID.Reset()
				if err := s.SourceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_id\"")
			}
		case "source_name":
			if err := func() error {
				s.SourceName.Reset()
				if err := s.SourceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_name\"")
			}
		case "destination_id":
			if err := func() error {
				s.DestinationID.Reset()
				if err := s.DestinationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination_id\"")
			}
		case "destination_name":
			if err := func() error {
				s.DestinationName.Reset()
				if err := s.DestinationName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination_name\"")
			}
		case "reconciled":
			if err := func() error {
				s.Reconciled.Reset()
				if err := s.Reconciled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reconciled\"")
			}
		case "piggy_bank_id":
			if err := func() error {
				s.PiggyBankID.Reset()
				if err := s.PiggyBankID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"piggy_bank_id\"")
			}
		case "piggy_bank_name":
			if err := func() error {
				s.PiggyBankName.Reset()
				if err := s.PiggyBankName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"piggy_bank_name\"")
			}
		case "bill_id":
			if err := func() error {
				s.BillID.Reset()
				if err := s.BillID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bill_id\"")
			}
		case "bill_name":
			if err := func() error {
				s.BillName.Reset()
				if err := s.BillName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bill_name\"")
			}
		case "tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "internal_reference":
			if err := func() error {
				s.InternalReference.Reset()
				if err := s.InternalReference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internal_reference\"")
			}
		case "external_id":
			if err := func() error {
				s.ExternalID.Reset()
				if err := s.ExternalID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_id\"")
			}
		case "external_url":
			if err := func() error {
				s.ExternalURL.Reset()
				if err := s.ExternalURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_url\"")
			}
		case "bunq_payment_id":
			if err := func() error {
				s.BunqPaymentID.Reset()
				if err := s.BunqPaymentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bunq_payment_id\"")
			}
		case "sepa_cc":
			if err := func() error {
				s.SepaCc.Reset()
				if err := s.SepaCc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_cc\"")
			}
		case "sepa_ct_op":
			if err := func() error {
				s.SepaCtOp.Reset()
				if err := s.SepaCtOp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_ct_op\"")
			}
		case "sepa_ct_id":
			if err := func() error {
				s.SepaCtID.Reset()
				if err := s.SepaCtID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_ct_id\"")
			}
		case "sepa_db":
			if err := func() error {
				s.SepaDb.Reset()
				if err := s.SepaDb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_db\"")
			}
		case "sepa_country":
			if err := func() error {
				s.SepaCountry.Reset()
				if err := s.SepaCountry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_country\"")
			}
		case "sepa_ep":
			if err := func() error {
				s.SepaEp.Reset()
				if err := s.SepaEp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_ep\"")
			}
		case "sepa_ci":
			if err := func() error {
				s.SepaCi.Reset()
				if err := s.SepaCi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_ci\"")
			}
		case "sepa_batch_id":
			if err := func() error {
				s.SepaBatchID.Reset()
				if err := s.SepaBatchID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_batch_id\"")
			}
		case "interest_date":
			if err := func() error {
				s.InterestDate.Reset()
				if err := s.InterestDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interest_date\"")
			}
		case "book_date":
			if err := func() error {
				s.BookDate.Reset()
				if err := s.BookDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"book_date\"")
			}
		case "process_date":
			if err := func() error {
				s.ProcessDate.Reset()
				if err := s.ProcessDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"process_date\"")
			}
		case "due_date":
			if err := func() error {
				s.DueDate.Reset()
				if err := s.DueDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"due_date\"")
			}
		case "payment_date":
			if err := func() error {
				s.PaymentDate.Reset()
				if err := s.PaymentDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payment_date\"")
			}
		case "invoice_date":
			if err := func() error {
				s.InvoiceDate.Reset()
				if err := s.InvoiceDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoice_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransactionSplitStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [6]uint8{
		0b00001111,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransactionSplitStore) {
					name = jsonFieldsNameOfTransactionSplitStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransactionSplitStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionSplitStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransactionSplitUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransactionSplitUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.TransactionJournalID.Set {
			e.FieldStart("transaction_journal_id")
			s.TransactionJournalID.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Order.Set {
			e.FieldStart("order")
			s.Order.Encode(e)
		}
	}
	{
		if s.CurrencyID.Set {
			e.FieldStart("currency_id")
			s.CurrencyID.Encode(e)
		}
	}
	{
		if s.CurrencyCode.Set {
			e.FieldStart("currency_code")
			s.CurrencyCode.Encode(e)
		}
	}
	{
		if s.CurrencySymbol.Set {
			e.FieldStart("currency_symbol")
			s.CurrencySymbol.Encode(e)
		}
	}
	{
		if s.CurrencyName.Set {
			e.FieldStart("currency_name")
			s.CurrencyName.Encode(e)
		}
	}
	{
		if s.CurrencyDecimalPlaces.Set {
			e.FieldStart("currency_decimal_places")
			s.CurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		if s.ForeignAmount.Set {
			e.FieldStart("foreign_amount")
			s.ForeignAmount.Encode(e)
		}
	}
	{
		if s.ForeignCurrencyID.Set {
			e.FieldStart("foreign_currency_id")
			s.ForeignCurrencyID.Encode(e)
		}
	}
	{
		if s.ForeignCurrencyCode.Set {
			e.FieldStart("foreign_currency_code")
			s.ForeignCurrencyCode.Encode(e)
		}
	}
	{
		if s.ForeignCurrencySymbol.Set {
			e.FieldStart("foreign_currency_symbol")
			s.ForeignCurrencySymbol.Encode(e)
		}
	}
	{
		if s.ForeignCurrencyDecimalPlaces.Set {
			e.FieldStart("foreign_currency_decimal_places")
			s.ForeignCurrencyDecimalPlaces.Encode(e)
		}
	}
	{
		if s.BudgetID.Set {
			e.FieldStart("budget_id")
			s.BudgetID.Encode(e)
		}
	}
	{
		if s.BudgetName.Set {
			e.FieldStart("budget_name")
			s.BudgetName.Encode(e)
		}
	}
	{
		if s.CategoryID.Set {
			e.FieldStart("category_id")
			s.CategoryID.Encode(e)
		}
	}
	{
		if s.CategoryName.Set {
			e.FieldStart("category_name")
			s.CategoryName.Encode(e)
		}
	}
	{
		if s.SourceID.Set {
			e.FieldStart("source_id")
			s.SourceID.Encode(e)
		}
	}
	{
		if s.SourceName.Set {
			e.FieldStart("source_name")
			s.SourceName.Encode(e)
		}
	}
	{
		if s.SourceIban.Set {
			e.FieldStart("source_iban")
			s.SourceIban.Encode(e)
		}
	}
	{
		if s.DestinationID.Set {
			e.FieldStart("destination_id")
			s.DestinationID.Encode(e)
		}
	}
	{
		if s.DestinationName.Set {
			e.FieldStart("destination_name")
			s.DestinationName.Encode(e)
		}
	}
	{
		if s.DestinationIban.Set {
			e.FieldStart("destination_iban")
			s.DestinationIban.Encode(e)
		}
	}
	{
		if s.Reconciled.Set {
			e.FieldStart("reconciled")
			s.Reconciled.Encode(e)
		}
	}
	{
		if s.BillID.Set {
			e.FieldStart("bill_id")
			s.BillID.Encode(e)
		}
	}
	{
		if s.BillName.Set {
			e.FieldStart("bill_name")
			s.BillName.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.Notes.Set {
			e.FieldStart("notes")
			s.Notes.Encode(e)
		}
	}
	{
		if s.InternalReference.Set {
			e.FieldStart("internal_reference")
			s.InternalReference.Encode(e)
		}
	}
	{
		if s.ExternalID.Set {
			e.FieldStart("external_id")
			s.ExternalID.Encode(e)
		}
	}
	{
		if s.ExternalURL.Set {
			e.FieldStart("external_url")
			s.ExternalURL.Encode(e)
		}
	}
	{
		if s.BunqPaymentID.Set {
			e.FieldStart("bunq_payment_id")
			s.BunqPaymentID.Encode(e)
		}
	}
	{
		if s.SepaCc.Set {
			e.FieldStart("sepa_cc")
			s.SepaCc.Encode(e)
		}
	}
	{
		if s.SepaCtOp.Set {
			e.FieldStart("sepa_ct_op")
			s.SepaCtOp.Encode(e)
		}
	}
	{
		if s.SepaCtID.Set {
			e.FieldStart("sepa_ct_id")
			s.SepaCtID.Encode(e)
		}
	}
	{
		if s.SepaDb.Set {
			e.FieldStart("sepa_db")
			s.SepaDb.Encode(e)
		}
	}
	{
		if s.SepaCountry.Set {
			e.FieldStart("sepa_country")
			s.SepaCountry.Encode(e)
		}
	}
	{
		if s.SepaEp.Set {
			e.FieldStart("sepa_ep")
			s.SepaEp.Encode(e)
		}
	}
	{
		if s.SepaCi.Set {
			e.FieldStart("sepa_ci")
			s.SepaCi.Encode(e)
		}
	}
	{
		if s.SepaBatchID.Set {
			e.FieldStart("sepa_batch_id")
			s.SepaBatchID.Encode(e)
		}
	}
	{
		if s.InterestDate.Set {
			e.FieldStart("interest_date")
			s.InterestDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.BookDate.Set {
			e.FieldStart("book_date")
			s.BookDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ProcessDate.Set {
			e.FieldStart("process_date")
			s.ProcessDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DueDate.Set {
			e.FieldStart("due_date")
			s.DueDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PaymentDate.Set {
			e.FieldStart("payment_date")
			s.PaymentDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.InvoiceDate.Set {
			e.FieldStart("invoice_date")
			s.InvoiceDate.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfTransactionSplitUpdate = [49]string{
	0:  "transaction_journal_id",
	1:  "type",
	2:  "date",
	3:  "amount",
	4:  "description",
	5:  "order",
	6:  "currency_id",
	7:  "currency_code",
	8:  "currency_symbol",
	9:  "currency_name",
	10: "currency_decimal_places",
	11: "foreign_amount",
	12: "foreign_currency_id",
	13: "foreign_currency_code",
	14: "foreign_currency_symbol",
	15: "foreign_currency_decimal_places",
	16: "budget_id",
	17: "budget_name",
	18: "category_id",
	19: "category_name",
	20: "source_id",
	21: "source_name",
	22: "source_iban",
	23: "destination_id",
	24: "destination_name",
	25: "destination_iban",
	26: "reconciled",
	27: "bill_id",
	28: "bill_name",
	29: "tags",
	30: "notes",
	31: "internal_reference",
	32: "external_id",
	33: "external_url",
	34: "bunq_payment_id",
	35: "sepa_cc",
	36: "sepa_ct_op",
	37: "sepa_ct_id",
	38: "sepa_db",
	39: "sepa_country",
	40: "sepa_ep",
	41: "sepa_ci",
	42: "sepa_batch_id",
	43: "interest_date",
	44: "book_date",
	45: "process_date",
	46: "due_date",
	47: "payment_date",
	48: "invoice_date",
}

// Decode decodes TransactionSplitUpdate from json.
func (s *TransactionSplitUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionSplitUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "transaction_journal_id":
			if err := func() error {
				s.TransactionJournalID.Reset()
				if err := s.TransactionJournalID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transaction_journal_id\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "order":
			if err := func() error {
				s.Order.Reset()
				if err := s.Order.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"order\"")
			}
		case "currency_id":
			if err := func() error {
				s.CurrencyID.Reset()
				if err := s.CurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_id\"")
			}
		case "currency_code":
			if err := func() error {
				s.CurrencyCode.Reset()
				if err := s.CurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_code\"")
			}
		case "currency_symbol":
			if err := func() error {
				s.CurrencySymbol.Reset()
				if err := s.CurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_symbol\"")
			}
		case "currency_name":
			if err := func() error {
				s.CurrencyName.Reset()
				if err := s.CurrencyName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_name\"")
			}
		case "currency_decimal_places":
			if err := func() error {
				s.CurrencyDecimalPlaces.Reset()
				if err := s.CurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency_decimal_places\"")
			}
		case "foreign_amount":
			if err := func() error {
				s.ForeignAmount.Reset()
				if err := s.ForeignAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_amount\"")
			}
		case "foreign_currency_id":
			if err := func() error {
				s.ForeignCurrencyID.Reset()
				if err := s.ForeignCurrencyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_currency_id\"")
			}
		case "foreign_currency_code":
			if err := func() error {
				s.ForeignCurrencyCode.Reset()
				if err := s.ForeignCurrencyCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_currency_code\"")
			}
		case "foreign_currency_symbol":
			if err := func() error {
				s.ForeignCurrencySymbol.Reset()
				if err := s.ForeignCurrencySymbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_currency_symbol\"")
			}
		case "foreign_currency_decimal_places":
			if err := func() error {
				s.ForeignCurrencyDecimalPlaces.Reset()
				if err := s.ForeignCurrencyDecimalPlaces.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreign_currency_decimal_places\"")
			}
		case "budget_id":
			if err := func() error {
				s.BudgetID.Reset()
				if err := s.BudgetID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"budget_id\"")
			}
		case "budget_name":
			if err := func() error {
				s.BudgetName.Reset()
				if err := s.BudgetName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"budget_name\"")
			}
		case "category_id":
			if err := func() error {
				s.CategoryID.Reset()
				if err := s.CategoryID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_id\"")
			}
		case "category_name":
			if err := func() error {
				s.CategoryName.Reset()
				if err := s.CategoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category_name\"")
			}
		case "source_id":
			if err := func() error {
				s.SourceID.Reset()
				if err := s.SourceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_id\"")
			}
		case "source_name":
			if err := func() error {
				s.SourceName.Reset()
				if err := s.SourceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_name\"")
			}
		case "source_iban":
			if err := func() error {
				s.SourceIban.Reset()
				if err := s.SourceIban.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_iban\"")
			}
		case "destination_id":
			if err := func() error {
				s.DestinationID.Reset()
				if err := s.DestinationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination_id\"")
			}
		case "destination_name":
			if err := func() error {
				s.DestinationName.Reset()
				if err := s.DestinationName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination_name\"")
			}
		case "destination_iban":
			if err := func() error {
				s.DestinationIban.Reset()
				if err := s.DestinationIban.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination_iban\"")
			}
		case "reconciled":
			if err := func() error {
				s.Reconciled.Reset()
				if err := s.Reconciled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reconciled\"")
			}
		case "bill_id":
			if err := func() error {
				s.BillID.Reset()
				if err := s.BillID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bill_id\"")
			}
		case "bill_name":
			if err := func() error {
				s.BillName.Reset()
				if err := s.BillName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bill_name\"")
			}
		case "tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "notes":
			if err := func() error {
				s.Notes.Reset()
				if err := s.Notes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notes\"")
			}
		case "internal_reference":
			if err := func() error {
				s.InternalReference.Reset()
				if err := s.InternalReference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internal_reference\"")
			}
		case "external_id":
			if err := func() error {
				s.ExternalID.Reset()
				if err := s.ExternalID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_id\"")
			}
		case "external_url":
			if err := func() error {
				s.ExternalURL.Reset()
				if err := s.ExternalURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_url\"")
			}
		case "bunq_payment_id":
			if err := func() error {
				s.BunqPaymentID.Reset()
				if err := s.BunqPaymentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bunq_payment_id\"")
			}
		case "sepa_cc":
			if err := func() error {
				s.SepaCc.Reset()
				if err := s.SepaCc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_cc\"")
			}
		case "sepa_ct_op":
			if err := func() error {
				s.SepaCtOp.Reset()
				if err := s.SepaCtOp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_ct_op\"")
			}
		case "sepa_ct_id":
			if err := func() error {
				s.SepaCtID.Reset()
				if err := s.SepaCtID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_ct_id\"")
			}
		case "sepa_db":
			if err := func() error {
				s.SepaDb.Reset()
				if err := s.SepaDb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_db\"")
			}
		case "sepa_country":
			if err := func() error {
				s.SepaCountry.Reset()
				if err := s.SepaCountry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_country\"")
			}
		case "sepa_ep":
			if err := func() error {
				s.SepaEp.Reset()
				if err := s.SepaEp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_ep\"")
			}
		case "sepa_ci":
			if err := func() error {
				s.SepaCi.Reset()
				if err := s.SepaCi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_ci\"")
			}
		case "sepa_batch_id":
			if err := func() error {
				s.SepaBatchID.Reset()
				if err := s.SepaBatchID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sepa_batch_id\"")
			}
		case "interest_date":
			if err := func() error {
				s.InterestDate.Reset()
				if err := s.InterestDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interest_date\"")
			}
		case "book_date":
			if err := func() error {
				s.BookDate.Reset()
				if err := s.BookDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"book_date\"")
			}
		case "process_date":
			if err := func() error {
				s.ProcessDate.Reset()
				if err := s.ProcessDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"process_date\"")
			}
		case "due_date":
			if err := func() error {
				s.DueDate.Reset()
				if err := s.DueDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"due_date\"")
			}
		case "payment_date":
			if err := func() error {
				s.PaymentDate.Reset()
				if err := s.PaymentDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payment_date\"")
			}
		case "invoice_date":
			if err := func() error {
				s.InvoiceDate.Reset()
				if err := s.InvoiceDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invoice_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransactionSplitUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransactionSplitUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionSplitUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransactionStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransactionStore) encodeFields(e *jx.Encoder) {
	{
		if s.ErrorIfDuplicateHash.Set {
			e.FieldStart("error_if_duplicate_hash")
			s.ErrorIfDuplicateHash.Encode(e)
		}
	}
	{
		if s.ApplyRules.Set {
			e.FieldStart("apply_rules")
			s.ApplyRules.Encode(e)
		}
	}
	{
		if s.FireWebhooks.Set {
			e.FieldStart("fire_webhooks")
			s.FireWebhooks.Encode(e)
		}
	}
	{
		if s.GroupTitle.Set {
			e.FieldStart("group_title")
			s.GroupTitle.Encode(e)
		}
	}
	{
		e.FieldStart("transactions")
		e.ArrStart()
		for _, elem := range s.Transactions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfTransactionStore = [5]string{
	0: "error_if_duplicate_hash",
	1: "apply_rules",
	2: "fire_webhooks",
	3: "group_title",
	4: "transactions",
}

// Decode decodes TransactionStore from json.
func (s *TransactionStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionStore to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error_if_duplicate_hash":
			if err := func() error {
				s.ErrorIfDuplicateHash.Reset()
				if err := s.ErrorIfDuplicateHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_if_duplicate_hash\"")
			}
		case "apply_rules":
			if err := func() error {
				s.ApplyRules.Reset()
				if err := s.ApplyRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apply_rules\"")
			}
		case "fire_webhooks":
			if err := func() error {
				s.FireWebhooks.Reset()
				if err := s.FireWebhooks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fire_webhooks\"")
			}
		case "group_title":
			if err := func() error {
				s.GroupTitle.Reset()
				if err := s.GroupTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_title\"")
			}
		case "transactions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Transactions = make([]TransactionSplitStore, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TransactionSplitStore
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Transactions = append(s.Transactions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransactionStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransactionStore) {
					name = jsonFieldsNameOfTransactionStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransactionStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransactionTypeProperty as json.
func (s TransactionTypeProperty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransactionTypeProperty from json.
func (s *TransactionTypeProperty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionTypeProperty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransactionTypeProperty(v) {
	case TransactionTypePropertyWithdrawal:
		*s = TransactionTypePropertyWithdrawal
	case TransactionTypePropertyDeposit:
		*s = TransactionTypePropertyDeposit
	case TransactionTypePropertyTransfer:
		*s = TransactionTypePropertyTransfer
	case TransactionTypePropertyReconciliation:
		*s = TransactionTypePropertyReconciliation
	case TransactionTypePropertyOpeningBalance:
		*s = TransactionTypePropertyOpeningBalance
	default:
		*s = TransactionTypeProperty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransactionTypeProperty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionTypeProperty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransactionUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransactionUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.ApplyRules.Set {
			e.FieldStart("apply_rules")
			s.ApplyRules.Encode(e)
		}
	}
	{
		if s.FireWebhooks.Set {
			e.FieldStart("fire_webhooks")
			s.FireWebhooks.Encode(e)
		}
	}
	{
		if s.GroupTitle.Set {
			e.FieldStart("group_title")
			s.GroupTitle.Encode(e)
		}
	}
	{
		if s.Transactions != nil {
			e.FieldStart("transactions")
			e.ArrStart()
			for _, elem := range s.Transactions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTransactionUpdate = [4]string{
	0: "apply_rules",
	1: "fire_webhooks",
	2: "group_title",
	3: "transactions",
}

// Decode decodes TransactionUpdate from json.
func (s *TransactionUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionUpdate to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apply_rules":
			if err := func() error {
				s.ApplyRules.Reset()
				if err := s.ApplyRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apply_rules\"")
			}
		case "fire_webhooks":
			if err := func() error {
				s.FireWebhooks.Reset()
				if err := s.FireWebhooks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fire_webhooks\"")
			}
		case "group_title":
			if err := func() error {
				s.GroupTitle.Reset()
				if err := s.GroupTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_title\"")
			}
		case "transactions":
			if err := func() error {
				s.Transactions = make([]TransactionSplitUpdate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TransactionSplitUpdate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Transactions = append(s.Transactions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transactions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransactionUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransactionUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Unauthenticated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Unauthenticated) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Exception.Set {
			e.FieldStart("exception")
			s.Exception.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnauthenticated = [2]string{
	0: "message",
	1: "exception",
}

// Decode decodes Unauthenticated from json.
func (s *Unauthenticated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Unauthenticated to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "exception":
			if err := func() error {
				s.Exception.Reset()
				if err := s.Exception.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exception\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Unauthenticated")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Unauthenticated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Unauthenticated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *User) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *User) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		if s.Blocked.Set {
			e.FieldStart("blocked")
			s.Blocked.Encode(e)
		}
	}
	{
		if s.BlockedCode.Set {
			e.FieldStart("blocked_code")
			s.BlockedCode.Encode(e)
		}
	}
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
}

var jsonFieldsNameOfUser = [6]string{
	0: "created_at",
	1: "updated_at",
	2: "email",
	3: "blocked",
	4: "blocked_code",
	5: "role",
}

// Decode decodes User from json.
func (s *User) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode User to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "blocked":
			if err := func() error {
				s.Blocked.Reset()
				if err := s.Blocked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked\"")
			}
		case "blocked_code":
			if err := func() error {
				s.BlockedCode.Reset()
				if err := s.BlockedCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked_code\"")
			}
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode User")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUser) {
					name = jsonFieldsNameOfUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *User) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *User) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfUserArray = [3]string{
	0: "data",
	1: "meta",
	2: "links",
}

// Decode decodes UserArray from json.
func (s *UserArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]UserRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserArray) {
					name = jsonFieldsNameOfUserArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserBlockedCodeProperty as json.
func (s UserBlockedCodeProperty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserBlockedCodeProperty from json.
func (s *UserBlockedCodeProperty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserBlockedCodeProperty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserBlockedCodeProperty(v) {
	case UserBlockedCodePropertyEmailChanged:
		*s = UserBlockedCodePropertyEmailChanged
	default:
		*s = UserBlockedCodeProperty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserBlockedCodeProperty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserBlockedCodeProperty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfUserRead = [4]string{
	0: "type",
	1: "id",
	2: "attributes",
	3: "links",
}

// Decode decodes UserRead from json.
func (s *UserRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserRead) {
					name = jsonFieldsNameOfUserRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserRoleProperty as json.
func (s UserRoleProperty) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserRoleProperty from json.
func (s *UserRoleProperty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserRoleProperty to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserRoleProperty(v) {
	case UserRolePropertyOwner:
		*s = UserRolePropertyOwner
	case UserRolePropertyDemo:
		*s = UserRolePropertyDemo
	default:
		*s = UserRoleProperty(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserRoleProperty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserRoleProperty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfUserSingle = [1]string{
	0: "data",
}

// Decode decodes UserSingle from json.
func (s *UserSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserSingle) {
					name = jsonFieldsNameOfUserSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationError) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Errors.Set {
			e.FieldStart("errors")
			s.Errors.Encode(e)
		}
	}
}

var jsonFieldsNameOfValidationError = [2]string{
	0: "message",
	1: "errors",
}

// Decode decodes ValidationError from json.
func (s *ValidationError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errors":
			if err := func() error {
				s.Errors.Reset()
				if err := s.Errors.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationErrorErrors) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationErrorErrors) encodeFields(e *jx.Encoder) {
	{
		if s.Email != nil {
			e.FieldStart("email")
			e.ArrStart()
			for _, elem := range s.Email {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Blocked != nil {
			e.FieldStart("blocked")
			e.ArrStart()
			for _, elem := range s.Blocked {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Role != nil {
			e.FieldStart("role")
			e.ArrStart()
			for _, elem := range s.Role {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.BlockedCode != nil {
			e.FieldStart("blocked_code")
			e.ArrStart()
			for _, elem := range s.BlockedCode {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Name != nil {
			e.FieldStart("name")
			e.ArrStart()
			for _, elem := range s.Name {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Type != nil {
			e.FieldStart("type")
			e.ArrStart()
			for _, elem := range s.Type {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Iban != nil {
			e.FieldStart("iban")
			e.ArrStart()
			for _, elem := range s.Iban {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Start != nil {
			e.FieldStart("start")
			e.ArrStart()
			for _, elem := range s.Start {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.End != nil {
			e.FieldStart("end")
			e.ArrStart()
			for _, elem := range s.End {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Date != nil {
			e.FieldStart("date")
			e.ArrStart()
			for _, elem := range s.Date {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfValidationErrorErrors = [10]string{
	0: "email",
	1: "blocked",
	2: "role",
	3: "blocked_code",
	4: "name",
	5: "type",
	6: "iban",
	7: "start",
	8: "end",
	9: "date",
}

// Decode decodes ValidationErrorErrors from json.
func (s *ValidationErrorErrors) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationErrorErrors to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			if err := func() error {
				s.Email = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Email = append(s.Email, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "blocked":
			if err := func() error {
				s.Blocked = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Blocked = append(s.Blocked, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked\"")
			}
		case "role":
			if err := func() error {
				s.Role = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Role = append(s.Role, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "blocked_code":
			if err := func() error {
				s.BlockedCode = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.BlockedCode = append(s.BlockedCode, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"blocked_code\"")
			}
		case "name":
			if err := func() error {
				s.Name = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Name = append(s.Name, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Type = append(s.Type, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "iban":
			if err := func() error {
				s.Iban = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Iban = append(s.Iban, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iban\"")
			}
		case "start":
			if err := func() error {
				s.Start = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Start = append(s.Start, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			if err := func() error {
				s.End = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.End = append(s.End, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "date":
			if err := func() error {
				s.Date = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Date = append(s.Date, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationErrorErrors")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationErrorErrors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationErrorErrors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Webhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Webhook) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
	{
		e.FieldStart("trigger")
		s.Trigger.Encode(e)
	}
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
	{
		e.FieldStart("delivery")
		s.Delivery.Encode(e)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfWebhook = [9]string{
	0: "created_at",
	1: "updated_at",
	2: "active",
	3: "title",
	4: "secret",
	5: "trigger",
	6: "response",
	7: "delivery",
	8: "url",
}

// Decode decodes Webhook from json.
func (s *Webhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Webhook to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "trigger":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Trigger.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trigger\"")
			}
		case "response":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		case "delivery":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Delivery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delivery\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Webhook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101000,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhook) {
					name = jsonFieldsNameOfWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Webhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Webhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfWebhookArray = [3]string{
	0: "data",
	1: "meta",
	2: "links",
}

// Decode decodes WebhookArray from json.
func (s *WebhookArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]WebhookRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WebhookRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhookArray) {
					name = jsonFieldsNameOfWebhookArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookAttempt) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookAttempt) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.WebhookMessageID.Set {
			e.FieldStart("webhook_message_id")
			s.WebhookMessageID.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("status_code")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Logs.Set {
			e.FieldStart("logs")
			s.Logs.Encode(e)
		}
	}
	{
		if s.Response.Set {
			e.FieldStart("response")
			s.Response.Encode(e)
		}
	}
}

var jsonFieldsNameOfWebhookAttempt = [6]string{
	0: "created_at",
	1: "updated_at",
	2: "webhook_message_id",
	3: "status_code",
	4: "logs",
	5: "response",
}

// Decode decodes WebhookAttempt from json.
func (s *WebhookAttempt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookAttempt to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "webhook_message_id":
			if err := func() error {
				s.WebhookMessageID.Reset()
				if err := s.WebhookMessageID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_message_id\"")
			}
		case "status_code":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status_code\"")
			}
		case "logs":
			if err := func() error {
				s.Logs.Reset()
				if err := s.Logs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logs\"")
			}
		case "response":
			if err := func() error {
				s.Response.Reset()
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookAttempt")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookAttempt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookAttempt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookAttemptArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookAttemptArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
}

var jsonFieldsNameOfWebhookAttemptArray = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes WebhookAttemptArray from json.
func (s *WebhookAttemptArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookAttemptArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]WebhookAttemptRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WebhookAttemptRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookAttemptArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhookAttemptArray) {
					name = jsonFieldsNameOfWebhookAttemptArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookAttemptArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookAttemptArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookAttemptRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookAttemptRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
}

var jsonFieldsNameOfWebhookAttemptRead = [3]string{
	0: "type",
	1: "id",
	2: "attributes",
}

// Decode decodes WebhookAttemptRead from json.
func (s *WebhookAttemptRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookAttemptRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookAttemptRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhookAttemptRead) {
					name = jsonFieldsNameOfWebhookAttemptRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookAttemptRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookAttemptRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookAttemptSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookAttemptSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfWebhookAttemptSingle = [1]string{
	0: "data",
}

// Decode decodes WebhookAttemptSingle from json.
func (s *WebhookAttemptSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookAttemptSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookAttemptSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhookAttemptSingle) {
					name = jsonFieldsNameOfWebhookAttemptSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookAttemptSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookAttemptSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookDelivery as json.
func (s WebhookDelivery) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WebhookDelivery from json.
func (s *WebhookDelivery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookDelivery to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WebhookDelivery(v) {
	case WebhookDeliveryJSON:
		*s = WebhookDeliveryJSON
	default:
		*s = WebhookDelivery(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookDelivery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookDelivery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookMessage) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Sent.Set {
			e.FieldStart("sent")
			s.Sent.Encode(e)
		}
	}
	{
		if s.Errored.Set {
			e.FieldStart("errored")
			s.Errored.Encode(e)
		}
	}
	{
		if s.WebhookID.Set {
			e.FieldStart("webhook_id")
			s.WebhookID.Encode(e)
		}
	}
	{
		if s.UUID.Set {
			e.FieldStart("uuid")
			s.UUID.Encode(e)
		}
	}
	{
		if s.String.Set {
			e.FieldStart("string")
			s.String.Encode(e)
		}
	}
}

var jsonFieldsNameOfWebhookMessage = [7]string{
	0: "created_at",
	1: "updated_at",
	2: "sent",
	3: "errored",
	4: "webhook_id",
	5: "uuid",
	6: "string",
}

// Decode decodes WebhookMessage from json.
func (s *WebhookMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookMessage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "sent":
			if err := func() error {
				s.Sent.Reset()
				if err := s.Sent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sent\"")
			}
		case "errored":
			if err := func() error {
				s.Errored.Reset()
				if err := s.Errored.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errored\"")
			}
		case "webhook_id":
			if err := func() error {
				s.WebhookID.Reset()
				if err := s.WebhookID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_id\"")
			}
		case "uuid":
			if err := func() error {
				s.UUID.Reset()
				if err := s.UUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "string":
			if err := func() error {
				s.String.Reset()
				if err := s.String.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"string\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookMessage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookMessageArray) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookMessageArray) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.ArrStart()
		for _, elem := range s.Data {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("meta")
		s.Meta.Encode(e)
	}
}

var jsonFieldsNameOfWebhookMessageArray = [2]string{
	0: "data",
	1: "meta",
}

// Decode decodes WebhookMessageArray from json.
func (s *WebhookMessageArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookMessageArray to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Data = make([]WebhookMessageRead, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WebhookMessageRead
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "meta":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookMessageArray")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhookMessageArray) {
					name = jsonFieldsNameOfWebhookMessageArray[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookMessageArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookMessageArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookMessageRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookMessageRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
}

var jsonFieldsNameOfWebhookMessageRead = [3]string{
	0: "type",
	1: "id",
	2: "attributes",
}

// Decode decodes WebhookMessageRead from json.
func (s *WebhookMessageRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookMessageRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookMessageRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhookMessageRead) {
					name = jsonFieldsNameOfWebhookMessageRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookMessageRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookMessageRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookMessageSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookMessageSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfWebhookMessageSingle = [1]string{
	0: "data",
}

// Decode decodes WebhookMessageSingle from json.
func (s *WebhookMessageSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookMessageSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookMessageSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhookMessageSingle) {
					name = jsonFieldsNameOfWebhookMessageSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookMessageSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookMessageSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookRead) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("attributes")
		s.Attributes.Encode(e)
	}
	{
		e.FieldStart("links")
		s.Links.Encode(e)
	}
}

var jsonFieldsNameOfWebhookRead = [4]string{
	0: "type",
	1: "id",
	2: "attributes",
	3: "links",
}

// Decode decodes WebhookRead from json.
func (s *WebhookRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "attributes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Attributes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhookRead) {
					name = jsonFieldsNameOfWebhookRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookResponse as json.
func (s WebhookResponse) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WebhookResponse from json.
func (s *WebhookResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookResponse to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WebhookResponse(v) {
	case WebhookResponseTRANSACTIONS:
		*s = WebhookResponseTRANSACTIONS
	case WebhookResponseACCOUNTS:
		*s = WebhookResponseACCOUNTS
	case WebhookResponseNONE:
		*s = WebhookResponseNONE
	default:
		*s = WebhookResponse(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookSingle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookSingle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
}

var jsonFieldsNameOfWebhookSingle = [1]string{
	0: "data",
}

// Decode decodes WebhookSingle from json.
func (s *WebhookSingle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookSingle to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookSingle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhookSingle) {
					name = jsonFieldsNameOfWebhookSingle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookSingle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookSingle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookStore) encodeFields(e *jx.Encoder) {
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("trigger")
		s.Trigger.Encode(e)
	}
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
	{
		e.FieldStart("delivery")
		s.Delivery.Encode(e)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfWebhookStore = [6]string{
	0: "active",
	1: "title",
	2: "trigger",
	3: "response",
	4: "delivery",
	5: "url",
}

// Decode decodes WebhookStore from json.
func (s *WebhookStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookStore to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "trigger":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Trigger.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trigger\"")
			}
		case "response":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		case "delivery":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Delivery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delivery\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookStore")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhookStore) {
					name = jsonFieldsNameOfWebhookStore[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookTrigger as json.
func (s WebhookTrigger) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WebhookTrigger from json.
func (s *WebhookTrigger) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookTrigger to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WebhookTrigger(v) {
	case WebhookTriggerSTORETRANSACTION:
		*s = WebhookTriggerSTORETRANSACTION
	case WebhookTriggerUPDATETRANSACTION:
		*s = WebhookTriggerUPDATETRANSACTION
	case WebhookTriggerDESTROYTRANSACTION:
		*s = WebhookTriggerDESTROYTRANSACTION
	default:
		*s = WebhookTrigger(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookTrigger) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookTrigger) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Active.Set {
			e.FieldStart("active")
			s.Active.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
	{
		if s.Trigger.Set {
			e.FieldStart("trigger")
			s.Trigger.Encode(e)
		}
	}
	{
		if s.Response.Set {
			e.FieldStart("response")
			s.Response.Encode(e)
		}
	}
	{
		if s.Delivery.Set {
			e.FieldStart("delivery")
			s.Delivery.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfWebhookUpdate = [7]string{
	0: "active",
	1: "title",
	2: "secret",
	3: "trigger",
	4: "response",
	5: "delivery",
	6: "url",
}

// Decode decodes WebhookUpdate from json.
func (s *WebhookUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "active":
			if err := func() error {
				s.Active.Reset()
				if err := s.Active.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "trigger":
			if err := func() error {
				s.Trigger.Reset()
				if err := s.Trigger.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trigger\"")
			}
		case "response":
			if err := func() error {
				s.Response.Reset()
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		case "delivery":
			if err := func() error {
				s.Delivery.Reset()
				if err := s.Delivery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delivery\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
